



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="go-forward" href="http://chungod.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="go-forward" href="http://chungod.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="go-forward" href="http://chungod.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  

<link rel="canonical" href="http://chungod.github.io/2021/05/04/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">



  <title>
 |
go-forward = 乌云后面依然是灿烂的晴天</title>
<meta name="generator" content="Hexo 5.4.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2021-05-04 16:58:29">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2021-05-04T16:58:29+08:00">2021-05-04</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">go-forward</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipetlbztpj20zk0m84qp.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicm0fdw5cj20zk0m8hdt.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclxfdlttj20zk0m8npd.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclh5u05ej20zk0m87df.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclil3m4ej20zk0m8tn8.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipex2cdtbj20zk0m8x6p.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="http://chungod.github.io/2021/05/04/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="chun">
    <meta itemprop="description" content="乌云后面依然是灿烂的晴天, 欢迎来到我的博客(*^﹏^*),本人为新人,你可以阅读我的学习笔记并提出独到的见解~我们将互相学习,共同进步,望大佬们勿喷">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="go-forward">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h2 id="python-核心编程总结"><a class="markdownIt-Anchor" href="#python-核心编程总结">#</a> <strong>python 核心编程总结</strong></h2>
<p><strong>如果是一个函数，用类名去调用，如果是一个方法，用对象去调用</strong></p>
<h3 id="第二章快速入门"><a class="markdownIt-Anchor" href="#第二章快速入门">#</a> <strong>第二章快速入门</strong></h3>
<p><strong>程序输入和 raw_input () 内建函数</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201106202520792.png" alt="image-20201106202520792"></strong></p>
<p><strong>下面是输入一个数值字符串（并将字符串转换为整型）的例子</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201106203129234.png" alt="image-20201106203129234"></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">格式化符号  转换</span><br><span class="line">	%s                              字符串      </span><br><span class="line">    %d                              有符号的十进制数 </span><br><span class="line">    %f                              浮点数</span><br><span class="line">    %c                              字符</span><br><span class="line">    %u                              无符号十进制数</span><br><span class="line">    %o                              八进制整数</span><br><span class="line">    %x                              十六进制整数（小写ox）</span><br><span class="line">    %X                              十六进制整数（大写OX）</span><br><span class="line">    %e                              科学技术法（小写e）</span><br><span class="line">    %E                              科学技术法（大写E）</span><br><span class="line">    %g                              %f 和 %e的简写</span><br><span class="line">    %G                              %f 和 %E的简写</span><br></pre></td></tr></table></figure>
<h3 id="运算符"><a class="markdownIt-Anchor" href="#运算符">#</a> <strong>运算符</strong></h3>
<p><strong>算术运算符</strong></p>
<p><strong>以下假设变量： a=10，b=20：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>运算符</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
<th style="text-align:left"><strong>实例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>+</strong></td>
<td style="text-align:left"><strong>加 - 两个对象相加</strong></td>
<td style="text-align:left"><strong>a + b 输出结果 30</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>-</strong></td>
<td style="text-align:left"><strong>减 - 得到负数或是一个数减去另一个数</strong></td>
<td style="text-align:left"><strong>a - b 输出结果 -10</strong></td>
</tr>
<tr>
<td style="text-align:left">*****</td>
<td style="text-align:left"><strong>乘 - 两个数相乘或是返回一个被重复若干次的字符串</strong></td>
<td style="text-align:left"><strong>a * b 输出结果 200</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>/</strong></td>
<td style="text-align:left"><strong>除 - x 除以 y</strong></td>
<td style="text-align:left"><strong>b /a 输出结果 2</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>%</strong></td>
<td style="text-align:left"><strong>取模 - 返回除法的余数</strong></td>
<td style="text-align:left"><strong>b % a 输出结果 0</strong></td>
</tr>
<tr>
<td style="text-align:left">******</td>
<td style="text-align:left"><strong>幂 - 返回 x 的 y 次幂</strong></td>
<td style="text-align:left"><strong>ab 为 10 的 20 次方， 输出结果 100000000000000000000</strong>**</td>
</tr>
<tr>
<td style="text-align:left"><strong>//</strong></td>
<td style="text-align:left"><strong>取整除 - 返回商的整数部分（向下取整）</strong></td>
<td style="text-align:left"><strong> <code>&gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5</code> </strong></td>
</tr>
</tbody>
</table>
<p><strong>比较运算符</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>运算符</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
<th style="text-align:left"><strong>实例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>==</strong></td>
<td style="text-align:left"><strong>等于 - 比较对象是否相等</strong></td>
<td style="text-align:left"><strong>(a == b) 返回 False。</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>!=</strong></td>
<td style="text-align:left"><strong>不等于 - 比较两个对象是否不相等</strong></td>
<td style="text-align:left"><strong>(a != b) 返回 true.</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>&lt;&gt;</strong></td>
<td style="text-align:left"><strong>不等于 - 比较两个对象是否不相等。python3 已废弃。</strong></td>
<td style="text-align:left"><strong>(a &lt;&gt; b) 返回 true。这个运算符类似！= 。</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>&gt;</strong></td>
<td style="text-align:left"><strong>大于 - 返回 x 是否大于 y</strong></td>
<td style="text-align:left"><strong>(a&gt; b) 返回 False。</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>&lt;</strong></td>
<td style="text-align:left"><strong>小于 - 返回 x 是否小于 y。所有比较运算符返回 1 表示真，返回 0 表示假。这分别与特殊的变量 True 和 False 等价。</strong></td>
<td style="text-align:left"><strong>(a &lt; b) 返回 true。</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>&gt;=</strong></td>
<td style="text-align:left"><strong>大于等于 - 返回 x 是否大于等于 y。</strong></td>
<td style="text-align:left"><strong>(a&gt;= b) 返回 False。</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>&lt;=</strong></td>
<td style="text-align:left"><strong>小于等于 - 返回 x 是否小于等于 y。</strong></td>
<td style="text-align:left"><strong>(a &lt;= b) 返回 true。</strong></td>
</tr>
</tbody>
</table>
<p><strong>赋值运算符</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>运算符</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
<th style="text-align:left"><strong>实例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>=</strong></td>
<td style="text-align:left"><strong>简单的赋值运算符</strong></td>
<td style="text-align:left"><strong>c = a + b 将 a + b 的运算结果赋值为 c</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>+=</strong></td>
<td style="text-align:left"><strong>加法赋值运算符</strong></td>
<td style="text-align:left"><strong>c += a 等效于 c = c + a</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>-=</strong></td>
<td style="text-align:left"><strong>减法赋值运算符</strong></td>
<td style="text-align:left"><strong>c -= a 等效于 c = c - a</strong></td>
</tr>
<tr>
<td style="text-align:left">*<strong>=</strong></td>
<td style="text-align:left"><strong>乘法赋值运算符</strong></td>
<td style="text-align:left">*<em>c <em>= a 等效于 c = c * a</em></em></td>
</tr>
<tr>
<td style="text-align:left"><strong>/=</strong></td>
<td style="text-align:left"><strong>除法赋值运算符</strong></td>
<td style="text-align:left"><strong>c /= a 等效于 c = c /a</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>%=</strong></td>
<td style="text-align:left"><strong>取模赋值运算符</strong></td>
<td style="text-align:left"><strong>c %= a 等效于 c = c % a</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>=</strong>**</td>
<td style="text-align:left"><strong>幂赋值运算符</strong></td>
<td style="text-align:left"><strong>c = a 等效于 c = c * * a</strong>**</td>
</tr>
<tr>
<td style="text-align:left"><strong>//=</strong></td>
<td style="text-align:left"><strong>取整除赋值运算符</strong></td>
<td style="text-align:left"><strong>c //= a 等效于 c = c //a</strong></td>
</tr>
</tbody>
</table>
<p><strong>位运算符</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>运算符</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
<th style="text-align:left"><strong>实例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>&amp;</strong></td>
<td style="text-align:left"><strong>按位与运算符：参与运算的两个值，如果两个相应位都为 1, 则该位的结果为 1, 否则为 0</strong></td>
<td style="text-align:left"><strong>(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>|</strong></td>
<td style="text-align:left"><strong>按位或运算符：只要对应的二个二进位有一个为 1 时，结果位就为 1。</strong></td>
<td style="text-align:left"><strong>(a | b) 输出结果 61 ，二进制解释： 0011 1101</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>^</strong></td>
<td style="text-align:left"><strong>按位异或运算符：当两对应的二进位相异时，结果为 1</strong></td>
<td style="text-align:left"><strong>(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>~</strong></td>
<td style="text-align:left"><strong>按位取反运算符：对数据的每个二进制位取反，即把 1 变为 0, 把 0 变为 1 。~x 类似于 -x-1</strong></td>
<td style="text-align:left"><strong>(~a) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>&lt;&lt;</strong></td>
<td style="text-align:left"><strong>左移动运算符：运算数的各二进位全部左移若干位，由 &lt;&lt; 右边的数字指定了移动的位数，高位丢弃，低位补 0。</strong></td>
<td style="text-align:left"><strong>a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>&gt;&gt;</strong></td>
<td style="text-align:left"><strong>右移动运算符：把 &quot;&gt;&gt;&quot; 左边的运算数的各二进位全部右移若干位，&gt;&gt; 右边的数字指定了移动的位数</strong></td>
<td style="text-align:left"><strong>a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</strong></td>
</tr>
</tbody>
</table>
<p><strong>逻辑运算符</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>运算符</strong></th>
<th style="text-align:left"><strong>逻辑表达式</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
<th style="text-align:left"><strong>实例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>and</strong></td>
<td style="text-align:left"><strong>x and y</strong></td>
<td style="text-align:left"><strong>布尔 &quot;与&quot; - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。</strong></td>
<td style="text-align:left"><strong>(a and b) 返回 20。</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>or</strong></td>
<td style="text-align:left"><strong>x or y</strong></td>
<td style="text-align:left"><strong>布尔 &quot;或&quot; - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。</strong></td>
<td style="text-align:left"><strong>(a or b) 返回 10。</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>not</strong></td>
<td style="text-align:left"><strong>not x</strong></td>
<td style="text-align:left"><strong>布尔 &quot;非&quot; - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</strong></td>
<td style="text-align:left"><strong>not (a and b) 返回 False</strong></td>
</tr>
</tbody>
</table>
<p><strong>成员运算符</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>运算符</strong></th>
<th><strong>描述</strong></th>
<th style="text-align:left"><strong>实例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>in</strong></td>
<td><strong>如果在指定的序列中找到值返回 True，否则返回 False。</strong></td>
<td style="text-align:left"><strong>x 在 y 序列中，如果 x 在 y 序列中返回 True。</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>not in</strong></td>
<td><strong>如果在指定的序列中没有找到值返回 True，否则返回 False。</strong></td>
<td style="text-align:left"><strong>x 不在 y 序列中，如果 x 不在 y 序列中返回 True。</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>strip()</strong></td>
<td><strong>只能移除字符串首尾的多余空格，也可用于移除类似空格等字符，如 * 等</strong></td>
<td style="text-align:left"><strong>分割字符串首尾空格</strong></td>
</tr>
</tbody>
</table>
<p><strong>身份运算符</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>运算符</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
<th style="text-align:left"><strong>实例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>is</strong></td>
<td style="text-align:left"><strong>is 是判断两个标识符是不是引用自一个对象</strong></td>
<td style="text-align:left"><strong>x is y, 类似 id (x) == id (y) , 如果引用的是同一个对象则返回 True，否则返回 False</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>is not</strong></td>
<td style="text-align:left"><strong>is not 是判断两个标识符是不是引用自不同对象</strong></td>
<td style="text-align:left"><strong>x is not y ， 类似 id (a) != id (b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。</strong></td>
</tr>
</tbody>
</table>
<p><strong>运算符优先级</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>运算符</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">******</td>
<td style="text-align:left"><strong>指数 (最高优先级)</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>~ + -</strong></td>
<td style="text-align:left"><strong>按位翻转，一元加号和减号 (最后两个的方法名为 +@ 和 -@)</strong></td>
</tr>
<tr>
<td style="text-align:left">*** / % //**</td>
<td style="text-align:left"><strong>乘，除，取模和取整除</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>+ -</strong></td>
<td style="text-align:left"><strong>加法减法</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>&gt;&gt; &lt;&lt;</strong></td>
<td style="text-align:left"><strong>右移，左移运算符</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>&amp;</strong></td>
<td style="text-align:left"><strong>位 'AND’</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>^ |</strong></td>
<td style="text-align:left"><strong>位运算符</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>&lt;= &lt; &gt; &gt;=</strong></td>
<td style="text-align:left"><strong>比较运算符</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>&lt;&gt; == !=</strong></td>
<td style="text-align:left"><strong>等于运算符</strong></td>
</tr>
<tr>
<td style="text-align:left">**= %= /= //= -= += *= <strong>=</strong></td>
<td style="text-align:left"><strong>赋值运算符</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>is is not</strong></td>
<td style="text-align:left"><strong>身份运算符</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>in not in</strong></td>
<td style="text-align:left"><strong>成员运算符</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>not and or</strong></td>
<td style="text-align:left"><strong>逻辑运算符</strong></td>
</tr>
</tbody>
</table>
<h2 id="字符串"><a class="markdownIt-Anchor" href="#字符串">#</a> <strong>字符串</strong></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Python 中字符串被定义为引号之间的字符集合。Python 支持使用成对的单引号或双引号，三引号（三个连续的单引号或者双引号）可以用来包含特殊字符。使用索引操作符（[ ]）和切片操作符（[ : ]）可以</span><br><span class="line">得到子字符串。字符串有其特有的索引规则：第一个字符的索引是 0，最后一个字符的索引是−1。</span><br></pre></td></tr></table></figure>
<h3 id="切片和"><a class="markdownIt-Anchor" href="#切片和">#</a> <strong>切片和’’'</strong></h3>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201106204746192.png" alt="image-20201106204746192"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201106204841872.png" alt="image-20201106204841872"></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">表和元组有几处重要的区别。列表元素用中括号（[ ]）包裹，元素的个数及元素的值可以改变。</span><br><span class="line">元组元素用小括号（( )）包裹，不可以更改（尽管他们的内容可以）。元组可以看成是只读的列表。通过</span><br><span class="line">切片运算（[ ] 和[ : ]）可以得到子集，这一点与字符串的使用方法一样。</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201106205101310.png" alt="image-20201106205101310"></strong></p>
<h3 id="元组"><a class="markdownIt-Anchor" href="#元组">#</a> <strong>元组</strong></h3>
<p><strong>元组也可以进行切片运算，得到的结果也是元组（不能被修改）。</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201106205331789.png" alt="image-20201106205331789"></strong></p>
<h3 id="字典"><a class="markdownIt-Anchor" href="#字典">#</a> <strong>字典</strong></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">字典是 Python 中的映射数据类型，工作原理类似 Perl 中的关联数组或哈希表，由键-值(key-value)</span><br><span class="line">对构成。几乎所有类型的 Python 对象都可以用作键，不过一般还是以数字或者字符串最为常用。</span><br><span class="line">值可以是任意类型的 Python 对象，字典元素用大括号（&#123; &#125;）包裹。</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201106205616891.png" alt="image-20201106205616891"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201106205710356.png" alt="image-20201106205710356"></strong></p>
<h2 id="条件语句"><a class="markdownIt-Anchor" href="#条件语句">#</a> <strong>条件语句</strong></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if 判断条件：</span><br><span class="line">    执行语句……</span><br><span class="line">else：</span><br><span class="line">    执行语句……</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201106210320295.png" alt="image-20201106210320295"></strong></p>
<p><strong>if 语句的判断条件可以用 &gt;（大于）、&lt;(小于)、==（等于）、&gt;=（大于等于）、&lt;=（小于等于）来表示其关系。</strong></p>
<p><strong>当判断条件为多个值时，可以使用以下形式：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if 判断条件1:</span><br><span class="line">    执行语句1……</span><br><span class="line">elif 判断条件2:</span><br><span class="line">    执行语句2……</span><br><span class="line">elif 判断条件3:</span><br><span class="line">    执行语句3……</span><br><span class="line">else:</span><br><span class="line">    执行语句4……</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201106211018154.png" alt="image-20201106211018154"></strong></p>
<p><strong>while 循环语句</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201106211442004.png" alt="image-20201106211442004"></strong></p>
<p><strong>for 语句</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">for iterating_var in sequence:</span><br><span class="line">   statements(s)</span><br><span class="line">对于按顺序迭代_var：</span><br><span class="line">报表</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107093806309.png" alt="image-20201107093806309"></strong></p>
<p><strong>range () 函数经常和 len () 函数一起用于字符串索引。在这里我们要显示每一个元素及其索引值。</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107094010643.png" alt="image-20201107094010643"></strong></p>
<p><strong>求质数	循环使用 else 语句</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107094635492.png" alt="image-20201107094635492"></strong></p>
<p><strong>不过，这些循环有一个约束，你要么循环索引，要么循环元素。这导致了 enumerate () 函数的推出</strong><br>
<strong>（Python2.3 新增）。它同时做到了这两点。</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107095256070.png" alt="image-20201107095256070"></strong></p>
<h2 id="列表解析"><a class="markdownIt-Anchor" href="#列表解析">#</a> <strong>列表解析</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107095444374.png" alt="image-20201107095444374"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107095639864.png" alt="image-20201107095639864"></strong></p>
<h2 id="open函数"><a class="markdownIt-Anchor" href="#open函数">#</a> <strong>open 函数</strong></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">函数语法</span><br><span class="line">open(name[, mode[, buffering]])</span><br><span class="line">参数说明：</span><br><span class="line"></span><br><span class="line">name : 一个包含了你要访问的文件名称的字符串值。</span><br><span class="line"></span><br><span class="line">mode : mode 决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。</span><br><span class="line"></span><br><span class="line">buffering : 如果 buffering 的值被设为 0，就不会有寄存。如果 buffering 的值取 1，访问文件时会寄存行。如果将 buffering 的值设为大于 1 的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。</span><br></pre></td></tr></table></figure>
<p><strong>不同模式打开文件的完全列表：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>模式</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>r</strong></td>
<td style="text-align:left"><strong>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>rb</strong></td>
<td style="text-align:left"><strong>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>r+</strong></td>
<td style="text-align:left"><strong>打开一个文件用于读写。文件指针将会放在文件的开头。</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>rb+</strong></td>
<td style="text-align:left"><strong>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>w</strong></td>
<td style="text-align:left"><strong>打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>wb</strong></td>
<td style="text-align:left"><strong>以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>w+</strong></td>
<td style="text-align:left"><strong>打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>wb+</strong></td>
<td style="text-align:left"><strong>以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>a</strong></td>
<td style="text-align:left"><strong>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>ab</strong></td>
<td style="text-align:left"><strong>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>a+</strong></td>
<td style="text-align:left"><strong>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>ab+</strong></td>
<td style="text-align:left"><strong>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>rU</strong></td>
<td style="text-align:left"><strong>以读方式打开，同时提供通用换行符支持 （PEP 278</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>rt</strong></td>
<td style="text-align:left"><strong>模式下，python 在读取文本时会自动把 \r\n 转换成 \n.</strong></td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用 &#39;r&#39; 或 &#39;U&#39; 模式打开的文件必须是已经存在的。使用 &#39;w&#39; 模式打开的文件若存在则首先清空，</span><br><span class="line">然后（重新）创建。以 &#39;a&#39; 模式打开的文件是为追加数据作准备的，所有写入的数据都将追加到文件的</span><br><span class="line">末尾。即使你 seek 到了其他的地方。如果文件不存在，将被自动创建，类似以 &#39;w&#39; 模式打开文件。</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201109085648133.png" alt="image-20201109085648133"></strong></p>
<h3 id="readreadlinereadlines"><a class="markdownIt-Anchor" href="#readreadlinereadlines">#</a> <strong>read.readline.readlines</strong></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">read()方法</span><br><span class="line">　　特点是：读取整个文件，将文件内容放到一个字符串变量中。</span><br><span class="line">　　劣势是：如果文件非常大，尤其是大于内存时，无法使用read()方法。</span><br><span class="line">　　</span><br><span class="line">readline()方法</span><br><span class="line">　　特点：readline()方法每次读取一行；返回的是一个字符串对象，保持当前行的内存</span><br><span class="line">　　缺点：比readlines慢得多</span><br><span class="line">readlines()方法</span><br><span class="line">　　特点：一次性读取整个文件；自动将文件内容分析成一个行的列表。</span><br></pre></td></tr></table></figure>
<h2 id="with-open-和-open"><a class="markdownIt-Anchor" href="#with-open-和-open">#</a> <strong>with open 和 open</strong></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用python的时候，会经常遇到文件数据库的open，但总会不小心忘了close</span><br><span class="line"></span><br><span class="line">用with open 语句就能很好的解决这个问题，它会在语句执行完后，自动执行close（）</span><br></pre></td></tr></table></figure>
<p><strong>如果需要改变编码，必须引入 io 库，否则 python3 会报错</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201109092717929.png" alt=""></strong></p>
<p><strong>with open 运行后就关闭文件（代替 close）</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201109093521654.png" alt="image-20201109093521654"></strong></p>
<h3 id="file-对象方法"><a class="markdownIt-Anchor" href="#file-对象方法">#</a> <strong>file 对象方法</strong></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">file.read([size])：size 未指定则返回整个文件，如果文件大小 &gt;2 倍内存则有问题，f.read()读到文件尾时返回&quot;&quot;(空字串)。</span><br><span class="line"></span><br><span class="line">file.readline()：返回一行。</span><br><span class="line"></span><br><span class="line">file.readlines([size]) ：返回包含size行的列表, size 未指定则返回全部行。</span><br><span class="line"></span><br><span class="line">for line in f: print line ：通过迭代器访问。</span><br><span class="line"></span><br><span class="line">f.write(&quot;hello\n&quot;)：如果要写入字符串以外的数据,先将他转换为字符串。</span><br><span class="line"></span><br><span class="line">f.tell()：返回一个整数,表示当前文件指针的位置(就是到文件头的字节数)。</span><br><span class="line"></span><br><span class="line">f.seek(偏移量,[起始位置])：用来移动文件指针。</span><br><span class="line"></span><br><span class="line">偏移量: 单位为字节，可正可负</span><br><span class="line">起始位置: 0 - 文件头, 默认值; 1 - 当前位置; 2 - 文件尾</span><br><span class="line">f.close() 关闭文件</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107102029412.png" alt="image-20201107102029412"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201109094923167.png" alt="image-20201109094923167"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201109093910729.png" alt="image-20201109093910729"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201109095006923.png" alt="image-20201109095006923"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201109095054041.png" alt="image-20201109095054041"></strong></p>
<h2 id="定义函数"><a class="markdownIt-Anchor" href="#定义函数">#</a> <strong>定义函数</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107134017412.png" alt="image-20201107134017412"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107134054158.png" alt="image-20201107134054158"></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数的返回值：</span><br><span class="line">    return 值：只能返回一次，只要执行return函数就终止</span><br><span class="line">    返回值：没有类型限制，也没有个数限制</span><br><span class="line">        没有return：None</span><br><span class="line">        返回一个值</span><br><span class="line">        返回多个值：元组</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="https://images2015.cnblogs.com/blog/1168160/201706/1168160-20170613150346509-2048706927.png" alt="img"></strong></p>
<h3 id="sys模块"><a class="markdownIt-Anchor" href="#sys模块">#</a> <strong>sys 模块</strong></h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sys.argv: 实现从程序外部向程序传递参数。</span><br><span class="line"></span><br><span class="line">sys.exit([arg]): 程序中间的退出，arg&#x3D;0为正常退出。</span><br><span class="line">sys.version  显示版本</span><br><span class="line">sys.stdout.write(&#39;please:&#39;):标准输出，引出进度条的例子</span><br><span class="line">sys.getrecursionlimit() :获取最大递归层数</span><br><span class="line">sys.setrecursionlimit(1200):设置最大递归层数</span><br><span class="line">sys.getdefaultencoding(): 获取系统当前编码，一般默认为ascii。</span><br><span class="line">sys.setdefaultencoding(): 设置系统默认编码，执行dir（sys）时不会看到这个方法，在解释器中执行不通过，可以先执行reload(sys)，在执行 setdefaultencoding(&#39;utf8&#39;)，此时将系统默认编码设置为utf8。（见设置系统默认编码 ）</span><br><span class="line"></span><br><span class="line">sys.getfilesystemencoding(): 获取文件系统使用编码方式，Windows下返回&#39;mbcs&#39;，mac下返回&#39;utf-8&#39;.</span><br><span class="line"></span><br><span class="line">sys.path: 获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中import时正确找到。</span><br><span class="line"></span><br><span class="line">sys.platform: 获取当前系统平台。</span><br><span class="line"></span><br><span class="line">sys.stdin,sys.stdout,sys.stderr: stdin , stdout , 以及stderr 变量包含与标准I&#x2F;O 流对应的流对象. 如果需要更好地控制输出,而print 不能满足你的要求, 它们就是你所需要的. 你也可以替换它们, 这时候你就可以重定向输出和输入到其它设备( device ), 或者以非标准的方式处理它们</span><br></pre></td></tr></table></figure>
<h3 id="实用函数内建函数"><a class="markdownIt-Anchor" href="#实用函数内建函数">#</a> <strong>实用函数（内建函数）</strong></h3>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107141353584.png" alt="image-20201107141353584"></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">PS：常用内置模块函数:</span><br><span class="line">abs(x)                    返回x的绝对值</span><br><span class="line">apply(func[,args[,kwargs]])        把函数的参数放置在序列中传入函数</span><br><span class="line">bool([x])                把每一个值或者表达式转换为bool类型，如果表达式x为值，则返回True,否则返回False</span><br><span class="line">cmp(x,y)                比较x,y的大小</span><br><span class="line">delattr(obj,name)            等价于del obj.name</span><br><span class="line">eval(s[,globals[,locals]])        计算表达式的值</span><br><span class="line">float(x)                把数字或者字符串转换成float类型数据</span><br><span class="line">hash(object)                返回一个对象的hash值</span><br><span class="line">help([object])                返回内联函数的帮助说明</span><br><span class="line">id(x)                    返回一个对象的标示</span><br><span class="line">input([prompt])                接受控制台的输入，并把输入的值转换成数字</span><br><span class="line">int(x)                    把数字或字符串转换为整型</span><br><span class="line">len(obj)                对象包含的元素的个数</span><br><span class="line">range([start,]end[,step])        生产一个列表并返回</span><br><span class="line">raw_input([prompt])            接受控制台的输入，返回字符串类型</span><br><span class="line">reduce(func,sequence[,initial])        对序列的值进行累加计算</span><br><span class="line">round(x,n&#x3D;0)                四舍五入的函数</span><br><span class="line">set([interable])            返回一个set集合</span><br><span class="line">sorted(iterable[,cmp[,key[,reverse]]])    返回一个排序后的列表</span><br><span class="line">sum(iterable[,start&#x3D;0])            返回一个序列的和</span><br><span class="line">type(obj)                返回一个对象的类型</span><br><span class="line">xrange(start[,end[,step]])        功能和range()类似，但是一次返回一个值</span><br><span class="line">zip(seq1[,seq2,…])            把n个序列作为列表的元素返回</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、apply()：可以调用可变参数列表的函数，把参数存在一个元组或者序列中，apply元组参数必须和sum()的参数一致</span><br><span class="line"></span><br><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line"># -*- coding:utf8 -*-</span><br><span class="line">def sum(x&#x3D;1,y&#x3D;2):</span><br><span class="line">  return x+y</span><br><span class="line">  </span><br><span class="line">print apply(sum,(1,3))  &#x3D;&gt;  4</span><br></pre></td></tr></table></figure>
<p><strong>1、假设是执行没有带参数的方法：</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107170811837.png" alt="image-20201107170811837"></strong></p>
<p><strong>2、函数只带元组的参数：</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107171030264.png" alt="image-20201107171030264"></strong></p>
<p><strong>3、函数带关键字参数：</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107171518321.png" alt="image-20201107171518321"></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2、filter()：可以对某个序列进行过滤，其中过滤的func()参数不能为空.</span><br><span class="line">filter(func or None,sequence) –&gt;list,tuple,or string</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107173311723.png" alt="image-20201107173311723"></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reduce() 函数会对参数序列中元素进行累积。</span><br><span class="line">函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107174224007.png" alt="image-20201107174224007"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107180053532.png" alt="image-20201107180053532"></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4、map()：可以对多个序列的每个元素都执行相同的操作，并组成列表返回。</span><br><span class="line">如果提供多个序列，则每个序列中的元素一一对应进行计算；如果每个序列的长度不相同，</span><br><span class="line">则短的序列后补充“None”,再进行计算</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107180555241.png" alt="image-20201107180555241"></strong></p>
<h2 id="语句和语法"><a class="markdownIt-Anchor" href="#语句和语法">#</a> <strong>语句和语法</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107151556112.png" alt="image-20201107151556112"></strong></p>
<p><strong>；语句（直接输入在一行）</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107151627702.png" alt="image-20201107151627702"></strong></p>
<p><strong>多元赋值</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107151814776.png" alt="image-20201107151814776"></strong></p>
<h2 id="python-关键字"><a class="markdownIt-Anchor" href="#python-关键字">#</a> <strong>python 关键字</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107151910582.png" alt="image-20201107151910582"></strong></p>
<p><strong>模块文档</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107152400729.png" alt="image-20201107152400729"></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主程序</span><br><span class="line">if name &#x3D;&#x3D; ‘main‘的意思是：当.py文件被直接运行时，if name &#x3D;&#x3D; ‘main‘之下的代码块将被运行；当.py文件以模块形式被导入时，if name &#x3D;&#x3D; ‘main‘之下的代码块不被运行。</span><br></pre></td></tr></table></figure>
<p><strong>del 语句</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;:  </span><br><span class="line">    a&#x3D;1       # 对象 1 被 变量a引用，对象1的引用计数器为1  </span><br><span class="line">    b&#x3D;a       # 对象1 被变量b引用，对象1的引用计数器加1  </span><br><span class="line">    c&#x3D;a       #1对象1 被变量c引用，对象1的引用计数器加1  </span><br><span class="line">    del a     #删除变量a，解除a对1的引用  </span><br><span class="line">    del b     #删除变量b，解除b对1的引用  </span><br><span class="line">    print(c)  #最终变量c仍然引用1  </span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">del删除的是变量，而不是数据。</span><br><span class="line"></span><br><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;:  </span><br><span class="line">    li&#x3D;[1,2,3,4,5]  #列表本身不包含数据1,2,3,4,5，而是包含变量：li[0] li[1] li[2] li[3] li[4]   </span><br><span class="line">    first&#x3D;li[0]     #拷贝列表，也不会有数据对象的复制，而是创建新的变量引用  </span><br><span class="line">    del li[0]  </span><br><span class="line">    print(li)      #输出[2, 3, 4, 5]  </span><br><span class="line">    print(first)   #输出 1  </span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107153700939.png" alt="image-20201107153700939"></strong></p>
<h2 id="切片"><a class="markdownIt-Anchor" href="#切片">#</a> <strong>切片</strong></h2>
<p><strong>切分 split ()  把字符串以某种字符为分隔符进行切分</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*.split() 以空格为分隔符切片</span><br><span class="line">print str.split(&#39; &#39;, 1 ); # 以空格为分隔符，分隔成两个</span><br><span class="line">*.split(&#39;,&#39;) 以，为分隔符切片</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107164910592.png" alt="image-20201107164910592"></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foolist[::-1]  翻转</span><br><span class="line">foostr[::2] 	隔一个取一个的操作</span><br><span class="line">foostr[::3]		隔两个取两个的操作</span><br><span class="line">foostr[2::]     截掉前两个取后面</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107153937933.png" alt="image-20201107153937933"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107181908777.png" alt="image-20201107181908777"></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[:]    切片s</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107182537467.png" alt="image-20201107182537467"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107182452238.png" alt="image-20201107182452238"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107154219008.png" alt="image-20201107154219008"></strong></p>
<h2 id="布尔类型"><a class="markdownIt-Anchor" href="#布尔类型">#</a> <strong>布尔类型</strong></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">布尔逻辑操作符 and、or和 not 都是 Python 关键字，这些操作符的优先级按从高到低的顺序列于表 4.3。</span><br><span class="line">not 操作符拥有最高优先级，只比所有比较操作符低一级。and 和 or 操作符则相应地再低一级</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107154354375.png" alt="image-20201107154354375"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107154530298.png" alt="image-20201107154530298"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107154915248.png" alt="image-20201107154915248"></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmp(obj1,obj2)将两数比较</span><br><span class="line">repr() 函数将对象转化为供解释器读取的形式。</span><br><span class="line">repr(object)</span><br><span class="line">type(obj)返回类型</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107155044932.png" alt="image-20201107155044932"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107155805451.png" alt="image-20201107155805451"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107160128104.png" alt="image-20201107160128104"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107160227570.png" alt="image-20201107160227570"></strong></p>
<h2 id="和"><a class="markdownIt-Anchor" href="#和">#</a> <strong>/ 和 //</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107160953628.png" alt="image-20201107160953628"></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; &#x2F; &quot;就一定表示 浮点数除法，返回浮点结果;&quot; &#x2F;&#x2F; &quot;表示整数除法</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107161431782.png" alt="image-20201107161431782"></strong></p>
<h2 id="数值工厂函数"><a class="markdownIt-Anchor" href="#数值工厂函数">#</a> <strong>数值工厂函数</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107161959650.png" alt="image-20201107161959650"></strong></p>
<h2 id="功能函数"><a class="markdownIt-Anchor" href="#功能函数">#</a> <strong>功能函数</strong></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abs()返回给定参数的绝对值</span><br><span class="line">函数 coerce()，尽管从技术上讲它是一个数据类型转换函数</span><br><span class="line">divmod()内建函数把除法和取余运算结合起来，返回一个包含商和余数的元组</span><br><span class="line">函数 pow() 和双星号 （**） 操作符都可以进行指数运算</span><br><span class="line">内建函数 round()用于对浮点型进行四舍五入运算</span><br></pre></td></tr></table></figure>
<h2 id="进制转换函数"><a class="markdownIt-Anchor" href="#进制转换函数">#</a> <strong>进制转换函数</strong></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bin()函数，是将十进制的数字转换成二进制的数字。</span><br><span class="line">oct()函数，是将十进制的数字转换成八进制的数字。</span><br><span class="line">int()函数，是将其他进制的数字转换成十进制的数字。</span><br><span class="line">hex()函数就是将十进制的数字转换成十六进制的数字。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">print(bin(10))</span><br><span class="line"># &#39;0b1010&#39; 0b就代表二进制数</span><br><span class="line">十进制转八进制oct()</span><br><span class="line">print(oct(10))</span><br><span class="line"># &#39;0o12&#39; 0o就代表八进制数</span><br><span class="line">十进制转十六进制hex()</span><br><span class="line">print(hex(10))</span><br><span class="line"># &#39;0xa&#39; 0x就代表十六进制数</span><br><span class="line">其他进制转十进制int(其他进制数字符串，进制)</span><br><span class="line"># 二进制转十进制</span><br><span class="line">print(int(&#39;0b1010&#39;, 2))</span><br><span class="line"># 10</span><br><span class="line"></span><br><span class="line"># 八进制转十进制</span><br><span class="line">print(int(&#39;0o12&#39;, 8))</span><br><span class="line"># 10</span><br><span class="line"></span><br><span class="line"># 十六进制转十进制</span><br><span class="line">print(int(&#39;0xa&#39;, 16))</span><br><span class="line"># 10</span><br></pre></td></tr></table></figure>
<h2 id="ascii转换函数"><a class="markdownIt-Anchor" href="#ascii转换函数">#</a> <strong>ASCII 转换函数</strong></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ord(&#39;a&#39;) &#x3D;&gt; 65</span><br><span class="line">chr(65)  &#x3D;&gt; a</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107165645096.png" alt="image-20201107165645096"></strong></p>
<h2 id="相关模块"><a class="markdownIt-Anchor" href="#相关模块">#</a> <strong>相关模块</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107181101383.png" alt="image-20201107181101383"></strong></p>
<p><strong>!(E:\typora 笔记 \typora-user-images\image-20201107181025707.png)</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107181041608.png" alt="image-20201107181041608"></strong></p>
<h2 id="类型转换"><a class="markdownIt-Anchor" href="#类型转换">#</a> <strong>类型转换</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107182941051.png" alt="image-20201107182941051"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201107182802039.png" alt="image-20201107182802039"></strong></p>
<p><strong>string 模块</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108134604160.png" alt="image-20201108134604160"></strong></p>
<h2 id="字符串符号"><a class="markdownIt-Anchor" href="#字符串符号">#</a> <strong>字符串符号</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108140449734.png" alt="image-20201108140449734"></strong></p>
<h2 id="格式化操作符辅助指令"><a class="markdownIt-Anchor" href="#格式化操作符辅助指令">#</a> <strong>格式化操作符辅助指令</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108140616882.png" alt="image-20201108140616882"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108140623536.png" alt="image-20201108140623536"></strong></p>
<p><strong>十六进制输出</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108140847577.png" alt="image-20201108140847577"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108141109107.png" alt="image-20201108141109107"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108141200464.png" alt="image-20201108141200464"></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">除了原始字符串符号（引号前面的字母“r”）以外，原始字符串跟普通字符串有着几乎完全相同的</span><br><span class="line">语法。这个&#39;r&#39;可以是小写也可以是大写，唯一的要求是必须紧靠在第一个引号前。在 3 个例子的第 1 个</span><br><span class="line">例子里面，我们需要一个反斜杠加一个“n”来而不是一个换行符。</span><br></pre></td></tr></table></figure>
<p><strong>如：</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108141427883.png" alt="image-20201108141427883"></strong></p>
<h2 id="enumerate"><a class="markdownIt-Anchor" href="#enumerate">#</a> <strong>enumerate()</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108141710055.png" alt="image-20201108141710055"></strong></p>
<h2 id="zip"><a class="markdownIt-Anchor" href="#zip">#</a> <strong>zip()</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108141851933.png" alt="image-20201108141851933"></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sorted() 排序</span><br><span class="line">sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。</span><br><span class="line"></span><br><span class="line">list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的</span><br><span class="line">操作。</span><br></pre></td></tr></table></figure>
<h2 id="reversed"><a class="markdownIt-Anchor" href="#reversed">#</a> <strong>reversed</strong></h2>
<p><strong>reversed 函数返回一个反转的迭代器。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python3</span><br><span class="line"> </span><br><span class="line"># 字符串</span><br><span class="line">seqString &#x3D; &#39;Runoob&#39;</span><br><span class="line">print(list(reversed(seqString)))</span><br><span class="line"> </span><br><span class="line"># 元组</span><br><span class="line">seqTuple &#x3D; (&#39;R&#39;, &#39;u&#39;, &#39;n&#39;, &#39;o&#39;, &#39;o&#39;, &#39;b&#39;)</span><br><span class="line">print(list(reversed(seqTuple)))</span><br><span class="line"> </span><br><span class="line"># range</span><br><span class="line">seqRange &#x3D; range(5, 9)</span><br><span class="line">print(list(reversed(seqRange)))</span><br><span class="line"> </span><br><span class="line"># 列表</span><br><span class="line">seqList &#x3D; [1, 2, 4, 3, 5]</span><br><span class="line">print(list(reversed(seqList)))</span><br></pre></td></tr></table></figure>
<h2 id="元组-2"><a class="markdownIt-Anchor" href="#元组-2">#</a> <strong>元组</strong></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">元组使用小括号，列表使用方括号。</span><br><span class="line">Python的元组与列表类似，不同之处在于元组的元素不能修改。</span><br><span class="line">元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。</span><br><span class="line">tup1 &#x3D; (&#39;physics&#39;, &#39;chemistry&#39;, 1997, 2000)</span><br><span class="line">tup2 &#x3D; (1, 2, 3, 4, 5, 6, 7 )</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108145756189.png" alt="image-20201108145756189"></strong></p>
<h2 id="列表类型内建函数"><a class="markdownIt-Anchor" href="#列表类型内建函数">#</a> <strong>列表类型内建函数</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108145843902.png" alt="image-20201108145843902"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108145952617.png" alt="image-20201108145952617"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108150033419.png" alt="image-20201108150033419"></strong></p>
<h2 id="字符串内建函数"><a class="markdownIt-Anchor" href="#字符串内建函数">#</a> <strong>字符串内建函数</strong></h2>
<p><strong>str_replace</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">把 将字符串中的 str1 替换成 str2,如果 max 指定，则替换不超过 max 次：replace(old, new [, max])</span><br><span class="line">str&#x3D;(&#39;Hello world&#39;)</span><br><span class="line">print (str.replace(&#39;Hello&#39;,&#39;hi&#39;)) #hi hi,World</span><br><span class="line">print (str.replace(&#39;Hello&#39;,&#39;hi&#39;,1)) #hi Hello,World</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108143535599.png" alt="image-20201108143535599"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108143549985.png" alt="image-20201108143549985"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108143559797.png" alt="image-20201108143559797"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108143734172.png" alt="image-20201108143734172"></strong></p>
<h2 id="相关模块-2"><a class="markdownIt-Anchor" href="#相关模块-2">#</a> <strong>相关模块</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108144340086.png" alt="image-20201108144340086"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108164946765.png" alt="image-20201108164946765"></strong></p>
<h2 id="浅拷贝和深拷贝"><a class="markdownIt-Anchor" href="#浅拷贝和深拷贝">#</a> <strong>浅拷贝和深拷贝</strong></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">直接赋值：其实就是对象的引用（别名）。</span><br><span class="line"></span><br><span class="line">浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象。</span><br><span class="line"></span><br><span class="line">深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。</span><br></pre></td></tr></table></figure>
<p><strong>浅拷贝</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108165303528.png" alt="image-20201108165303528"></strong></p>
<p><strong>深拷贝需要引入 copy 模块</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108165433607.png" alt="image-20201108165433607"></strong></p>
<h2 id="映射类型字典"><a class="markdownIt-Anchor" href="#映射类型字典">#</a> <strong>映射类型：字典</strong></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">字典是另一种可变容器模型，且可存储任意类型对象。</span><br><span class="line">第 1 个元素是字典的键，第 2 个元素是字典中的值。</span><br><span class="line"></span><br><span class="line">字典的每个键值 key&#x3D;&gt;value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 &#123;&#125; 中 ,格式如下所示：</span><br><span class="line"></span><br><span class="line">d &#x3D; &#123;key1 : value1, key2 : value2 &#125;</span><br></pre></td></tr></table></figure>
<p><strong>可直接</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108165949714.png" alt="image-20201108165949714"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108170457563.png" alt="image-20201108170457563"></strong></p>
<p><strong>也可以用工厂函数 dict 创建字典</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108170119982.png" alt="image-20201108170119982"></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以用一个很方便的内建方法 fromkeys() 来创建一个“默认”字典，字典中</span><br><span class="line">元素具有相同的值 （如果没有给出， 默认为 None）：</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108170308120.png" alt="image-20201108170308120"></strong></p>
<p><strong>访问字典中的值</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108170614048.png" alt="image-20201108170614048"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108170857435.png" alt="image-20201108170857435"></strong></p>
<h2 id="映射类型相关的函数"><a class="markdownIt-Anchor" href="#映射类型相关的函数">#</a> <strong>映射类型相关的函数</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108171657548.png" alt="image-20201108171657548"></strong></p>
<p><strong>a=dict(x=1,y=2)</strong></p>
<p><strong>顺序是乱的</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108171818778.png" alt="image-20201108171818778"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108172146325.png" alt="image-20201108172146325"></strong></p>
<h2 id="dict"><a class="markdownIt-Anchor" href="#dict">#</a> <strong>dict.*()</strong></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1	dict.clear()</span><br><span class="line">删除字典内所有元素</span><br><span class="line">2	dict.copy()</span><br><span class="line">返回一个字典的浅复制</span><br><span class="line">3	dict.fromkeys(seq[, val])</span><br><span class="line">创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值</span><br><span class="line">4	dict.get(key, default&#x3D;None)</span><br><span class="line">返回指定键的值，如果值不在字典中返回default值</span><br><span class="line">5	dict.has_key(key)</span><br><span class="line">如果键在字典dict里返回true，否则返回false</span><br><span class="line">6	dict.items()</span><br><span class="line">以列表返回可遍历的(键, 值) 元组数组</span><br><span class="line">7	dict.keys()</span><br><span class="line">以列表返回一个字典所有的键</span><br><span class="line">8	dict.setdefault(key, default&#x3D;None)</span><br><span class="line">和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</span><br><span class="line">9	dict.update(dict2)</span><br><span class="line">把字典dict2的键&#x2F;值对更新到dict里</span><br><span class="line">10	dict.values()</span><br><span class="line">以列表返回字典中的所有值</span><br><span class="line">11	pop(key[,default])</span><br><span class="line">删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</span><br><span class="line">12	popitem()</span><br><span class="line">返回并删除字典中的最后一对键和值。</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108173115716.png" alt="image-20201108173115716"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108173424551.png" alt="image-20201108173424551"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108174029827.png" alt="image-20201108174029827"></strong></p>
<h2 id="set和frozenset"><a class="markdownIt-Anchor" href="#set和frozenset">#</a> <strong>set 和 frozenset</strong></h2>
<p><strong>如何创建集合类型和给集合赋值</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(可变集合)与frozenset(不可变集合)的区别：</span><br><span class="line">set无序排序且不重复，是可变的，有add（），remove（）等方法。既然是可变的，所以它不存在哈希值。基本功能包括关系测试和消除重复元素. 集合对象还支持union(联合), intersection(交集), difference(差集)和sysmmetric difference(对称差集)等数学运算.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frozenset是冻结的集合，它是不可变的，存在哈希值，好处是它可以作为字典的key，也可以作为其它集合的元素。缺点是一旦创建便不能更改，没有add，remove方法。</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108191142034.png" alt="image-20201108191142034"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108191316221.png" alt="image-20201108191316221"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108191545218.png" alt="image-20201108191545218"></strong></p>
<p><strong>清除 del</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108191648687.png" alt="image-20201108191648687"></strong></p>
<p><strong>集合类型操作符（所有的集合类型）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1．联合（|）  并集   s | t</span><br><span class="line">2．交集（&amp;） s &amp; t</span><br><span class="line">3．差补&#x2F;相对补集（–） s - t</span><br><span class="line">4．对称差分（^）   s ^ t</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108192337063.png" alt="image-20201108192337063"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108192354662.png" alt="image-20201108192354662"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108192406467.png" alt="image-20201108192406467"></strong></p>
<h2 id="条件语句-2"><a class="markdownIt-Anchor" href="#条件语句-2">#</a> <strong>条件语句</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108203026167.png" alt="image-20201108203026167"></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if 判断条件：</span><br><span class="line">    执行语句……</span><br><span class="line">else：</span><br><span class="line">    执行语句……</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if 判断条件1:</span><br><span class="line">    执行语句1……</span><br><span class="line">elif 判断条件2:</span><br><span class="line">    执行语句2……</span><br><span class="line">elif 判断条件3:</span><br><span class="line">    执行语句3……</span><br><span class="line">else:</span><br><span class="line">    执行语句4……</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while 语句</span><br><span class="line"></span><br><span class="line">while 条件():</span><br><span class="line">  条件满足时,做的事情1</span><br><span class="line">  条件满足时,做的事情2</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while True循环语句：（死循环）</span><br><span class="line">采用该语句的核心思想是如果出现错误的话，可以继续循环。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for循环语句</span><br><span class="line">for循环使用的语法:</span><br><span class="line">for 变量 in 序列:</span><br><span class="line">    循环要执行的动作</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">range 语句</span><br><span class="line">range(start, stop[, step])</span><br><span class="line">range(0,30,5)  [0,5,10,15,20]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">break语句</span><br><span class="line">在语句块执行过程中终止循环，并且跳出整个循环</span><br><span class="line">continue</span><br><span class="line">语句在语句块执行过程中终止当前循环，跳出该次循环，执行下一次循环。</span><br><span class="line">pass语句</span><br><span class="line">是空语句，是为了保持程序结构的完整性</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">  可能产生异常的代码块</span><br><span class="line">except [ (Error1, Error2, ... ) [as e] ]:</span><br><span class="line">  处理异常的代码块1</span><br><span class="line">except [ (Error3, Error4, ... ) [as e] ]:</span><br><span class="line">  处理异常的代码块2</span><br><span class="line">except [Exception]:</span><br><span class="line">  处理其它异常</span><br></pre></td></tr></table></figure>
<h2 id="与序列相关的内建函数"><a class="markdownIt-Anchor" href="#与序列相关的内建函数">#</a> <strong>与序列相关的内建函数</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108205005894.png" alt="image-20201108205005894"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108205037907.png" alt="image-20201108205037907"></strong></p>
<h2 id="矩阵样例"><a class="markdownIt-Anchor" href="#矩阵样例">#</a> <strong>矩阵样例</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201108210152217.png" alt="image-20201108210152217"></strong></p>
<h2 id="os-模块的文件目录访问函数"><a class="markdownIt-Anchor" href="#os-模块的文件目录访问函数">#</a> <strong>os 模块的文件 / 目录访问函数</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201109101533347.png" alt="image-20201109101533347"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201109101540515.png" alt="image-20201109101540515"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201109101546504.png" alt="image-20201109101546504"></strong></p>
<h2 id="ospath模块中的路径名访问函数"><a class="markdownIt-Anchor" href="#ospath模块中的路径名访问函数">#</a> <strong>os.path 模块中的路径名访问函数</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201109101616641.png" alt="image-20201109101616641"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201109101622143.png" alt="image-20201109101622143"></strong></p>
<h2 id="相关模块-3"><a class="markdownIt-Anchor" href="#相关模块-3">#</a> <strong>相关模块</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201109103410350.png" alt="image-20201109103410350"></strong></p>
<h2 id="python-中的异常错误"><a class="markdownIt-Anchor" href="#python-中的异常错误">#</a> <strong>python 中的异常错误</strong></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1．NameError：尝试访问一个未申明的变量</span><br><span class="line">2．ZeroDivisionError：除数为零   1&#x2F;0</span><br><span class="line">3．SyntaxError：Python 解释器语法错误  for</span><br><span class="line">4．IndexError：请求的索引超出序列范围  a&#x3D;[]  a[0]</span><br><span class="line">5．KeyError：请求一个不存在的字典关键字 </span><br><span class="line">a&#x3D;&#123;&#39;host&#39;:&#39;earth&#39;&#125;   print a[server&#39;&#39;]</span><br><span class="line">6．IOError：输入&#x2F;输出错误 f&#x3D;open(&quot;blash&quot;)</span><br><span class="line">7．AttributeError：尝试访问未知的对象属性 class</span><br></pre></td></tr></table></figure>
<h2 id="try-except语句"><a class="markdownIt-Anchor" href="#try-except语句">#</a> <strong>try-except 语句</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201109105052905.png" alt="image-20201109105052905"></strong></p>
<h2 id="raise语句"><a class="markdownIt-Anchor" href="#raise语句">#</a> <strong>raise 语句</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201109163221607.png" alt="image-20201109163221607"></strong></p>
<h2 id="python-内建异常"><a class="markdownIt-Anchor" href="#python-内建异常">#</a> <strong>python 内建异常</strong></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">异 常 名 称</span><br><span class="line">描 述</span><br><span class="line">BaseExceptiona  所有异常的基类</span><br><span class="line">SystemExitbpython 解释器请求退出</span><br><span class="line">KeyboardInterruptc 用户中断执行（通常是输入^C）</span><br><span class="line">Exceptiond 常规错误的基类</span><br><span class="line">StopIterationn 迭代器没有更多的值</span><br><span class="line">GeneratorExita</span><br><span class="line">生成器（generator）发生异常来通知退出</span><br><span class="line">SystemExith Python 解释器请求退出</span><br><span class="line">StandardErrorg 所有的内建标准异常的基类</span><br><span class="line">ArithmeticErrord 所有数值计算错误的基类</span><br><span class="line">FloatingPointErrord 浮点计算错误</span><br><span class="line">OverflowError 数值运算超出最大限制</span><br><span class="line">ZeroDivisionError 除（或取模）零（所有数据类型）AssertionErrord 断言语句失败</span><br><span class="line">AttributeError 对象没有这个属性</span><br><span class="line">EOFError 没有内建输入，到达 EOF 标记</span><br><span class="line">EnvironmentErrord 操作系统错误的基类</span><br><span class="line">IOError 输入&#x2F;输出操作失败</span><br><span class="line">OSErrord 操作系统错误</span><br><span class="line">WindowsErrorh Windows 系统调用失败</span><br><span class="line">ImportError 导入模块&#x2F;对象失败</span><br><span class="line">KeyboardInterruptf 用户中断执行（通常是输入^C）</span><br><span class="line">LookupErrord 无效数据查询的基类</span><br><span class="line">IndexError 序列中没有没有此索引（index）</span><br><span class="line">KeyError 映射中没有这个键</span><br><span class="line">MemoryError 内存溢出错误（对于 Python 解释器不是致命的）</span><br><span class="line">NameError 未声明&#x2F;初始化对象（没有属性）</span><br><span class="line">UnboundLocalErrorh 访问未初始化的本地变量</span><br><span class="line">ReferenceErrore 弱引用（Weak reference）试图访问已经垃圾回收了的对象</span><br><span class="line">RuntimeError 一般的运行时错误</span><br><span class="line">NotImplementedErrord 尚未实现的方法</span><br><span class="line">SyntaxError Python 语法错误</span><br><span class="line">IndentationErrorg 缩进错误</span><br><span class="line">TabErrorg Tab 和空格混用</span><br><span class="line">SystemError 一般的解释器系统错误</span><br><span class="line">TypeError 对类型无效的操作</span><br><span class="line">ValueError 传入无效的参数</span><br><span class="line">UnicodeErrorh Unicode 相关的错误</span><br><span class="line">UnicodeDecodeErrori Unicode 解码时的错误</span><br><span class="line">UnicodeEncodeErrori Unicode 编码时错误</span><br><span class="line">UnicodeTranslateErrorf Unicode 转换时错误</span><br><span class="line">Warningj 警告的基类</span><br><span class="line">DeprecationWarningj 关于被弃用的特征的警告</span><br><span class="line">FutureWarningi 关于构造将来语义会有改变的警告</span><br><span class="line">OverflowWarningk 旧的关于自动提升为长整型（long）的警告</span><br><span class="line">PendingDeprecationWarningi 关于特性将会被废弃的警告</span><br><span class="line">RuntimeWarningj 可疑的运行时行为（runtime behavior）的警告</span><br><span class="line">SyntaxWarningj 可疑的语法的警告</span><br><span class="line">UserWarningj 用户代码生成的警告</span><br></pre></td></tr></table></figure>
<h2 id="operator模块"><a class="markdownIt-Anchor" href="#operator模块">#</a> <strong>operator 模块</strong></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">operator模块输出一系列对应Python内部操作符的函数。例如：operator.add(x, y)等价于表达式x+y。许多函数的名称都被一些特定的方法使用，没有下划线加持。为了向下兼容，它们中的许多都保留着由双下划线的变体。那些不具备双下划线的变体是为了使表达更清晰。</span><br><span class="line">这些函数在各种函数目录里扮演者对相比较、逻辑操作、数学运算以及序列操作等角色。</span><br></pre></td></tr></table></figure>
<h2 id="python代码中的funcargskwargs"><a class="markdownIt-Anchor" href="#python代码中的funcargskwargs">#</a> <strong>python 代码中的 func (<em>args,kwargs)</em></strong>*</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这是Python函数可变参数 args及kwargs</span><br><span class="line"></span><br><span class="line">*args表示任何多个无名参数，它是一个tuple</span><br><span class="line"></span><br><span class="line">**kwargs表示关键字参数，它是一个dic</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201110144620227.png" alt="image-20201110144620227"></strong></p>
<p><strong>运行结果</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201110144637303.png" alt="image-20201110144637303"></strong></p>
<h2 id="lambda"><a class="markdownIt-Anchor" href="#lambda">#</a> <strong>lambda</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201110160627942.png" alt="image-20201110160627942"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201110160804981.png" alt="image-20201110160804981"></strong></p>
<p><em><strong>x 元组      x 字典</strong></em> *</p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201110160953805.png" alt="image-20201110160953805"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201110172746858.png" alt="image-20201110172746858"></strong></p>
<h2 id="global用法"><a class="markdownIt-Anchor" href="#global用法">#</a> <strong>global 用法</strong></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Python中定义函数时，若想在函数内部对函数外的变量进行操作，就需要在函数内部声明其为global。</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201110193303076.png" alt="image-20201110193303076"></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加了global，则可以在函数内部对函数外的对象进行操作了，也可以改变它的值了</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201110193353117.png" alt="image-20201110193353117"></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">global需要在函数内部声明，若在函数外声明，则函数依然无法操作x</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201110193517358.png" alt="image-20201110193517358"></strong></p>
<h2 id="python-名称空间与作用域"><a class="markdownIt-Anchor" href="#python-名称空间与作用域">#</a> <strong>python 名称空间与作用域</strong></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Python 的名称（Name）是对象的一个标识（Identifier）。我们知道，在 Python 里面一切皆对象，名称就是用来引用对象的。说得有点玄乎，我们以例子说明。</span><br><span class="line"></span><br><span class="line">例如，在a &#x3D; 2这个语句中，2是个存储在内存中的一个对象，名称a则会引用2这个对象，“引用”的含义是指可以通过名称a来使用2这个对象。我们可以使用id()函数来获取对象的地址。</span><br><span class="line">a &#x3D; 2</span><br><span class="line">print(id(2))  &#x3D;&gt; 43547988</span><br><span class="line">print(id(a))  &#x3D;&gt; 43547988</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Python 的名称与对象</span><br><span class="line"></span><br><span class="line">起初，名称a引用对象2；</span><br><span class="line">然后，执行操作a &#x3D; a + 1，这时对象3被创建，名称a引用对象3，所以id(a)和id(3)输出相同的地址;</span><br><span class="line">最后，执行b &#x3D; 2，名称b引用对象2，所以id(2)和id(b)输出相同的地址</span><br><span class="line"></span><br><span class="line">这个例子也展示了 Python 在执行变量的赋值时，并不会重复创建一个对象的事实。名称采用动态绑定的机制使得 Python 更加高效，同一个名称可以引用不同类型的对象。</span><br><span class="line"></span><br><span class="line">a &#x3D; 5</span><br><span class="line">a &#x3D; &#39;hello world&#39;</span><br><span class="line">a &#x3D; [1, 2, 3]</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">可以看到，a先后引用了数字，字符串，列表的类型的对象，这在 Python 中完全是合法的。</span><br></pre></td></tr></table></figure>
<p><strong>名称空间</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">内置名称空间，例如，内置名称空间包含 Python 的内置函数，如，abs()</span><br><span class="line">模块名称空间，全局名称空间，在模块内定义的名称</span><br><span class="line">局部名称空间，例如，在函数（function）或者类（class）被调用时，其内部包含的名称</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201110203037210.png" alt=""></strong></p>
<p><strong>变量的作用域</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Python 的作用域（scope）决定了我们在程序中能否直接使用名称空间中的名称，直接访问的意思是指不需要在名称前添加名称空间的前缀。对于 Python 来说，至少存在以下三类的作用域。</span><br><span class="line"></span><br><span class="line">函数作用域，包括了函数内的局部名称</span><br><span class="line">模块作用域，包括了模块内的全局名称</span><br><span class="line">内置作用域，包括了内置名称</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201110204400798.png" alt="image-20201110204400798"></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先给定一个原则：函数中的变量为局部变量，首先在该函数体中寻找该变量的值，且是按顺序寻找的，找不到的话再去函数外面的全局变量需找。同理，函数外部的变量首先在全局变量寻找，寻找不到就找不到了，函数中定义的话，是没用的。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1、j &#x3D;&#x3D; 3 and k&#x3D;&#x3D; 4</span><br><span class="line">程序中首先执行的是proc1()，此时在函数proc1()中寻找j,k的局部变量，为j&#x3D;3,k&#x3D;4。</span><br><span class="line"></span><br><span class="line">2、j &#x3D;&#x3D; 1 and k&#x3D;&#x3D; 7</span><br><span class="line">程序然后执行：print(“j &#x3D;&#x3D; %d and k&#x3D;&#x3D; %d” % (j,k))</span><br><span class="line">在全局变量中寻找变量j,k的值，得到答案。</span><br><span class="line"></span><br><span class="line">3、j &#x3D;&#x3D; 3 and k&#x3D;&#x3D; 4</span><br><span class="line">程序随后执行proc2()。</span><br><span class="line">函数proc2()中首先执行proc1()，此时得到的结果如同1.</span><br><span class="line"></span><br><span class="line">4、j &#x3D;&#x3D; 6 and k&#x3D;&#x3D; 7</span><br><span class="line">然后执行函数proc2()中的：print(“j &#x3D;&#x3D; %d and k&#x3D;&#x3D; %d” % (j,k))</span><br><span class="line">此时先从函数proc2()中寻找j,k的值，结果只找到第10行，j&#x3D;6，k值函数proc2()中没有定义，就从函数外寻找，找到第14行的，k&#x3D;7，得到结果。</span><br><span class="line"></span><br><span class="line">5、j &#x3D;&#x3D; 8 and k&#x3D;&#x3D; 7</span><br><span class="line">这个就很明显了，从全局变量寻找变量的值。</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201110205413997.png" alt="image-20201110205413997"></strong></p>
<h2 id="from-import-语句"><a class="markdownIt-Anchor" href="#from-import-语句">#</a> <strong>from-import 语句</strong></h2>
<figure class="highlight plain"><figcaption><span>from-import 语句</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">你可以在你的模块里导入指定的模块属性。也就是把指定名称导入到当前作用域。使用 from-import</span><br><span class="line">异步社区Kensuke(18319066421) 专享 请尊重版权</span><br><span class="line">12.4 导入模块 317</span><br><span class="line">语句可以实现我们的目的，它的语法是：</span><br><span class="line">from module import name1[, name2[,... nameN]]</span><br></pre></td></tr></table></figure>
<h2 id="format格式化函数"><a class="markdownIt-Anchor" href="#format格式化函数">#</a> <strong>format 格式化函数</strong></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。</span><br><span class="line"></span><br><span class="line">基本语法是通过 &#123;&#125; 和 : 来代替以前的 % 。</span><br><span class="line">format 函数可以接受不限个参数，位置可以不按顺序。</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201111180151642.png" alt="image-20201111180151642"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201111185849334.png" alt="image-20201111185849334"></strong></p>
<p><strong>str.format () 传入对象</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201111190242360.png" alt="image-20201111190242360"></strong></p>
<h2 id="join"><a class="markdownIt-Anchor" href="#join">#</a> <strong>join()</strong></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread中，join（）方法的作用是调用线程等待该线程完成后，才能继续用下运行。</span><br></pre></td></tr></table></figure>
<h2 id="threading"><a class="markdownIt-Anchor" href="#threading">#</a> <strong>threading</strong></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">- threading的使用</span><br><span class="line">    - 直接利用threading.Thread生成Thread实例</span><br><span class="line">1. t &#x3D; threading.Thread(target&#x3D;xxx, args&#x3D;(xxx,))</span><br><span class="line">2. t.start():启动多线程</span><br><span class="line">3. t.join(): 等待多线程执行完成</span><br><span class="line">4. 案例04</span><br><span class="line">5. 案例05: 加入join后比较跟案例04的结果的异同</span><br><span class="line">  - 守护线程-daemon</span><br><span class="line">  - 如果在程序中将子线程设置成守护现成，则子线程会在主线程结束的时候自动退出</span><br><span class="line">  - 一般认为，守护线程不中要或者不允许离开主线程独立运行</span><br><span class="line">  - 守护线程案例能否有效果跟环境相关</span><br><span class="line">  - 案例06非守护线程</span><br><span class="line">  - 案例07守护线程  </span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程常用属性</span><br><span class="line">           -  threading.currentThread：返回当前线程变量</span><br><span class="line">           - threading.enumerate:返回一个包含正在运行的线程的list，正在运行的线程指的是线程启动后，结束前的状态</span><br><span class="line">           - threading.activeCount: 返回正在运行的线程数量，效果跟 len(threading.enumerate)相同</span><br><span class="line">           - thr.setName: 给线程设置名字</span><br><span class="line">           - thr.getName: 得到线程的名字</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> subprocess</span><br><span class="line">    - 完全跳过线程，使用进程</span><br><span class="line">    - 是派生进程的主要替代方案</span><br><span class="line">    - python2.4后引入</span><br><span class="line">- multiprocessiong</span><br><span class="line">    - 使用threadiing借口派生，使用子进程</span><br><span class="line">    - 允许为多核或者多cpu派生进程，接口跟threading非常相似</span><br><span class="line">    - python2.6</span><br><span class="line">    </span><br><span class="line">- concurrent.futures</span><br><span class="line">    - 新的异步执行模块</span><br><span class="line">    - 任务级别的操作</span><br><span class="line">    - python3.2后引入</span><br></pre></td></tr></table></figure>
<h2 id="queue模块线程间通信"><a class="markdownIt-Anchor" href="#queue模块线程间通信">#</a> <strong>queue 模块 (线程间通信)</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201115104731877.png" alt="image-20201115104731877"></strong></p>
<h2 id="optparse模块"><a class="markdownIt-Anchor" href="#optparse模块">#</a> <strong>optparse 模块</strong></h2>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Python 有两个内建的模块用于处理命令行参数：</span><br><span class="line">一个是 getopt，《Deep <span class="keyword">in</span> python》一书中也有提到，只能简单处理命令行参数；</span><br><span class="line">另一个是 optparse，它功能强大，而且易于使用，可以方便地生成标准的、符合Unix/Posix 规范的命令行说明。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">说回正题。当我们要利用server与client进行FTP文件传输的时候，在client端往往需要输入诸如 -s <span class="number">10.10</span><span class="number">.10</span><span class="number">.1</span> -p <span class="number">9001</span> 这样的信息，当然我们不能控制用户的输入，如果用户随意的输入错误的命令，比如不写IP地址，只是写-s -p <span class="number">9001</span>，或者只写 -s -p。我们如果还用sys.argv获取参数的话需要做很多麻烦的逻辑判断，这给我们开发程序带来了很大的不便。</span><br><span class="line"></span><br><span class="line">　　但是如果我们利用optparse会十分便捷的解决这样的问题。</span><br></pre></td></tr></table></figure>
<p><strong>optparse 用法如下</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> optparse</span><br><span class="line">parser = optparse.OptionParser()</span><br><span class="line">parser.add_option(<span class="string">&quot;-s&quot;</span>, <span class="string">&quot;--server&quot;</span>, dest=<span class="string">&quot;server&quot;</span>, help=<span class="string">&quot;ftp server ip_address&quot;</span>)</span><br><span class="line">parser.add_option(<span class="string">&quot;-P&quot;</span>, <span class="string">&quot;--port&quot;</span>, type=<span class="string">&quot;int&quot;</span>, dest=<span class="string">&quot;port&quot;</span>, help=<span class="string">&quot;ftp server port&quot;</span>)</span><br><span class="line">parser.add_option(<span class="string">&quot;-u&quot;</span>, <span class="string">&quot;--username&quot;</span>, dest=<span class="string">&quot;username&quot;</span>, help=<span class="string">&quot;username info&quot;</span>)</span><br><span class="line">parser.add_option(<span class="string">&quot;-p&quot;</span>, <span class="string">&quot;--password&quot;</span>, dest=<span class="string">&quot;password&quot;</span>, help=<span class="string">&quot;password info&quot;</span>)   </span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　首先import optparse类，然后创建optparse对象parser，再使用add_option()来定义命令行参数，最后使用parse_args()来解析命令行。</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201115092603340.png" alt="image-20201115092603340"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201115092624204.png" alt="image-20201115092624204"></strong></p>
<h2 id="sysargv用法简明"><a class="markdownIt-Anchor" href="#sysargv用法简明">#</a> <strong>sys.argv [] 用法简明</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201115085754249.png" alt="image-20201115085754249"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201115090603888.png" alt="image-20201115090603888"></strong></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">那我们再把代码修改一下：</span><br><span class="line">a=sys.argv[<span class="number">2</span>：]</span><br><span class="line">保存后，再从控制台窗台运行程序，这次多加几个参数，以空格隔开:</span><br><span class="line">得到的结果为[‘b’, ’c’, ’d’, ’e’, ’f’]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201115090659198.png" alt="image-20201115090659198"></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sys.argv[ ]其实就是一个列表，里边的项为用户输入的参数，关键就是要明白这参数是从程序外部输入的，而非代码本身的什么地方，要想看到它的效果就应该将程序保存了，从外部来运行程序并给出参数。</span><br></pre></td></tr></table></figure>
<h2 id="socket-模块"><a class="markdownIt-Anchor" href="#socket-模块">#</a> <strong>socket 模块</strong></h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socket.socket()创建一个类型为套接字类型socket.SOCK_STREAM的sock对象，默认使用TCP协议</span><br><span class="line">socket.AF_INET 面向网络的因特网</span><br><span class="line">socket.SOCK_DGRAM创建UDP的socket是不可靠的。而且数据据的读取写发送是可以无序的</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s.bind()　绑定地址(ip地址,端口)到套接字,参数必须是元组的格式例如：s.bind((&#x27;<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>&#x27;,<span class="number">8009</span>))</span><br><span class="line">s.listen(<span class="number">5</span>)　　开始监听，<span class="number">5</span>为最大挂起的连接数</span><br><span class="line">s.accept()　　被动接受客户端连接，阻塞，等待连接</span><br><span class="line">客户端套接字函数</span><br><span class="line">s.connect()　　连接服务器端，参数必须是元组格式例如：</span><br><span class="line">s.connect((&#x27;<span class="number">127</span>,<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>&#x27;,<span class="number">8009</span>))</span><br><span class="line">公共用途的套接字函数</span><br><span class="line">s.recv(<span class="number">1024</span>)　　接收TCP数据，<span class="number">1024</span>为一次数据接收的大小</span><br><span class="line">s.send(bytes)　　发送TCP数据，python3发送数据的格式必须为bytes格式</span><br><span class="line">s.sendall()　　完整发送数据，内部循环调用send</span><br><span class="line">s.close()　　关闭套接字</span><br><span class="line">s.recvfrom()  接受UDP数据</span><br><span class="line">s.sendto()  发送UDP数据</span><br></pre></td></tr></table></figure>
<h2 id="time-模块"><a class="markdownIt-Anchor" href="#time-模块">#</a> <strong>time 模块</strong></h2>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">time</span>.localtime([secs])：将一个时间戳转换为当前时区的struct_time,以当前时间为准。</span><br><span class="line"><span class="built_in">time</span>.<span class="built_in">time</span>()：返回当前时间的时间戳。</span><br><span class="line"><span class="built_in">time</span>.sleep(secs)：线程推迟指定的时间运行。单位为秒。</span><br><span class="line">strftime(<span class="built_in">format</span>[, t ])</span><br><span class="line"><span class="built_in">format</span>  - 格式字符串 t - 可选的参数t是一个struct_time对象</span><br><span class="line">返回值：可读字符串标识的当地时间</span><br><span class="line">gmtime()</span><br><span class="line">参数：转换为<span class="built_in">time</span>.stryct_time类型的对面的秒数</span><br><span class="line">ctime()</span><br><span class="line">参数: 要转换为字符串时间的秒数</span><br><span class="line">clock()</span><br><span class="line">返回值：</span><br><span class="line">该函数有两个功能，</span><br><span class="line">在第一次调用的时候，返回的是程序运行的实际时间；</span><br><span class="line">以第二次之后的调用，返回的是自第一次调用后,到这次调用的时间间隔</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201115104610446.png" alt="image-20201115104610446"></strong></p>
<h2 id="subprocess-模块"><a class="markdownIt-Anchor" href="#subprocess-模块">#</a> <strong>subprocess 模块</strong></h2>
<p><strong>subprocess 模块中的常用函数</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>函数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>subprocess.run()</strong></td>
<td><strong>Python 3.5 中新增的函数。执行指定的命令，等待命令执行完成后返回一个包含执行结果的 CompletedProcess 类的实例。</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>subprocess.call()</strong></td>
<td><strong>执行指定的命令，返回命令执行状态，其功能类似于 os.system (cmd)。</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>subprocess.check_call()</strong></td>
<td><strong>Python 2.5 中新增的函数。 执行指定的命令，如果执行成功则返回状态码，否则抛出异常。其功能等价于 subprocess.run (…, check=True)。</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>subprocess.check_output()</strong></td>
<td><strong>Python 2.7 中新增的的函数。执行指定的命令，如果执行状态码为 0 则返回命令执行结果，否则抛出异常。</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>subprocess.getoutput(cmd)</strong></td>
<td><strong>接收字符串格式的命令，执行命令并返回执行结果，其功能类似于 os.popen (cmd).read () 和 commands.getoutput (cmd)。</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>subprocess.getstatusoutput(cmd)</strong></td>
<td><strong>执行 cmd 命令，返回一个元组 (命令执行状态，命令执行结果输出)，其功能类似于 commands.getstatusoutput ()。</strong></td>
</tr>
</tbody>
</table>
<h2 id="os模块"><a class="markdownIt-Anchor" href="#os模块">#</a> <strong>os 模块</strong></h2>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">os.sep:取代操作系统特定的路径分隔符</span></span><br><span class="line"><span class="function"><span class="title">os.name</span>:指示你正在使用的工作平台。比如对于<span class="title">Windows</span>，它是&#x27;<span class="title">nt</span>&#x27;，而对于<span class="title">Linux</span>/<span class="title">Unix</span>用户，它是&#x27;<span class="title">posix</span>&#x27;。</span></span><br><span class="line"><span class="function"><span class="title">os.getcwd</span>:得到当前工作目录，即当前<span class="title">python</span>脚本工作的目录路径。</span></span><br><span class="line"><span class="function"><span class="title">os.getenv</span>()和<span class="title">os.putenv</span>:分别用来读取和设置环境变量</span></span><br><span class="line"><span class="function"><span class="title">os.listdir</span>():返回指定目录下的所有文件和目录名</span></span><br><span class="line"><span class="function"><span class="title">os.remove</span>(<span class="title">file</span>):删除一个文件</span></span><br><span class="line"><span class="function"><span class="title">os.stat</span>（<span class="title">file</span>）:获得文件属性</span></span><br><span class="line"><span class="function">20<span class="title">os.chmod</span>(<span class="title">file</span>):修改文件权限和时间戳</span></span><br><span class="line"><span class="function"><span class="title">os.mkdir</span>(<span class="title">name</span>):创建目录</span></span><br><span class="line"><span class="function"><span class="title">os.rmdir</span>(<span class="title">name</span>):删除目录</span></span><br><span class="line"><span class="function"><span class="title">os.removedirs</span>（<span class="title">r</span>“<span class="title">c</span>：\<span class="title">python</span>”）:删除多个目录</span></span><br><span class="line"><span class="function"><span class="title">os.system</span>():运行<span class="title">shell</span>命令</span></span><br><span class="line"><span class="function"><span class="title">os.exit</span>():终止当前进程</span></span><br><span class="line"><span class="function"><span class="title">os.linesep</span>:给出当前平台的行终止符。例如，<span class="title">Windows</span>使用&#x27;\<span class="title">r</span>\<span class="title">n</span>&#x27;，<span class="title">Linux</span>使用&#x27;\<span class="title">n</span>&#x27;而<span class="title">Mac</span>使用&#x27;\<span class="title">r</span>&#x27;</span></span><br><span class="line"><span class="function"><span class="title">os.path.split</span>(): 返回一个路径的目录名和文件名</span></span><br><span class="line"><span class="function"><span class="title">os.path.isfile</span>()和<span class="title">os.path.isdir</span>()分别检验给出的路径是一个目录还是文件</span></span><br><span class="line"><span class="function"><span class="title">os.path.existe</span>():检验给出的路径是否真的存在</span></span><br><span class="line"><span class="function"><span class="title">os.listdir</span>(<span class="title">dirname</span>):列出<span class="title">dirname</span>下的目录和文件</span></span><br><span class="line"><span class="function"><span class="title">os.getcwd</span>():获得当前工作目录</span></span><br><span class="line"><span class="function"><span class="title">os.curdir</span>:返回当前目录（&#x27;.&#x27;）</span></span><br><span class="line"><span class="function"><span class="title">os.chdir</span>(<span class="title">dirname</span>):改变工作目录到<span class="title">dirname</span></span></span><br><span class="line"><span class="function"><span class="title">os.path.isdir</span>(<span class="title">name</span>):判断<span class="title">name</span>是不是目录，不是目录就返回<span class="title">false</span></span></span><br><span class="line"><span class="function"><span class="title">os.path.isfile</span>(<span class="title">name</span>):判断<span class="title">name</span>这个文件是否存在，不存在返回<span class="title">false</span></span></span><br><span class="line"><span class="function"><span class="title">os.path.exists</span>(<span class="title">name</span>):判断是否存在文件或目录<span class="title">name</span></span></span><br><span class="line"><span class="function"><span class="title">os.path.getsize</span>(<span class="title">name</span>):或得文件大小，如果<span class="title">name</span>是目录返回0<span class="title">L</span></span></span><br><span class="line"><span class="function"><span class="title">os.path.abspath</span>(<span class="title">name</span>):获得绝对路径</span></span><br><span class="line"><span class="function"><span class="title">os.path.isabs</span>():判断是否为绝对路径</span></span><br><span class="line"><span class="function"><span class="title">os.path.normpath</span>(<span class="title">path</span>):规范<span class="title">path</span>字符串形式</span></span><br><span class="line"><span class="function"><span class="title">os.path.split</span>(<span class="title">name</span>):分割文件名与目录（事实上，如果你完全使用目录，它也会将最后一个目录作为文件名而分离，同时它不会判断文件或目录是否存在）</span></span><br><span class="line"><span class="function"><span class="title">os.path.splitext</span>():分离文件名和扩展名</span></span><br><span class="line"><span class="function"><span class="title">os.path.join</span>(<span class="title">path</span>,<span class="title">name</span>):连接目录与文件名或目录</span></span><br><span class="line"><span class="function"><span class="title">os.path.basename</span>(<span class="title">path</span>):返回文件名</span></span><br><span class="line"><span class="function"><span class="title">os.path.dirname</span>(<span class="title">path</span>):返回文件路径</span></span><br></pre></td></tr></table></figure>
<p><strong>文件操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">os.&#96;&#96;mknod&#96;&#96;(&#96;&#96;&quot;text.txt&quot;&#96;&#96;)：创建空文件</span><br><span class="line">fp &#x3D; &#96;&#96;open&#96;&#96;(&#96;&#96;&quot;text.txt&quot;&#96;&#96;,w):直接打开一个文件，如果文件不存在就创建文件</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">w 写方式</span><br><span class="line">a 追加模式打开（从EOF开始，必要时创建新文件）</span><br><span class="line">r+ 以读写模式打开</span><br><span class="line">w+ 以读写模式打开</span><br><span class="line">a+ 以读写模式打开</span><br><span class="line">rb 以二进制读模式打开</span><br><span class="line">wb 以二进制写模式打开 (参见 w )</span><br><span class="line">ab 以二进制追加模式打开 (参见 a )</span><br><span class="line">rb+ 以二进制读写模式打开 (参见 r+ )</span><br><span class="line">wb+ 以二进制读写模式打开 (参见 w+ )</span><br><span class="line">ab+ 以二进制读写模式打开 (参见 a+ )</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">fp.read([size])  #size为读取的长度，以byte为单位</span><br><span class="line"> </span><br><span class="line">fp.readline([size])  #读一行，如果定义了size，有可能返回的只是一行的一部分</span><br><span class="line"> </span><br><span class="line">fp.readlines([size])  #把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。</span><br><span class="line"> </span><br><span class="line">fp.write(str)  #把str写到文件中，write()并不会在str后加上一个换行符</span><br><span class="line"> </span><br><span class="line">fp.writelines(seq)  #把seq的内容全部写到文件中(多行一次性写入)。这个函数也只是忠实地写入，不会在每行后面加上任何东西。</span><br><span class="line"> </span><br><span class="line">fp.close()  #关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。 如果一个文件在关闭后还对其进行操作会产生ValueError</span><br><span class="line"> </span><br><span class="line">fp.flush()  #把缓冲区的内容写入硬盘</span><br><span class="line"> </span><br><span class="line">fp.fileno()  #返回一个长整型的”文件标签“</span><br><span class="line"> </span><br><span class="line">fp.isatty()  #文件是否是一个终端设备文件（unix系统中的）</span><br><span class="line"> </span><br><span class="line">fp.tell()  #返回文件操作标记的当前位置，以文件的开头为原点</span><br><span class="line"> </span><br><span class="line">fp.next()  #返回下一行，并将文件操作标记位移到下一行。把一个file用于<span class="keyword">for</span> … <span class="keyword">in</span> file这样的语句时，就是调用next()函数来实现遍历的。</span><br><span class="line"> </span><br><span class="line">fp.seek(offset[,whence])  #将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为<span class="number">0</span>表示从头开始计算，<span class="number">1</span>表示以当前位置为原点计算。<span class="number">2</span>表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。</span><br><span class="line"> </span><br><span class="line">fp.truncate([size])  #把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，也可能是用<span class="number">0</span>把文件补到相应的大小，也可能是以一些随机的内容加上去。</span><br><span class="line"> </span><br><span class="line">目录操作</span><br><span class="line"> </span><br><span class="line">os.<span class="built_in">mkdir</span>(&quot;file&quot;)　　创建目录</span><br><span class="line"> </span><br><span class="line">shutil.copyfile(&quot;oldfile&quot;,&quot;newfile&quot;)　　复制文件:oldfile和newfile都只能是文件</span><br><span class="line"> </span><br><span class="line">shutil.<span class="built_in">copy</span>(&quot;oldfile&quot;,&quot;newfile&quot;)  oldfile只能是文件夹，newfile可以是文件，也可以是目标目录</span><br><span class="line"> </span><br><span class="line">shutil.copytree(&quot;olddir&quot;,&quot;newdir&quot;)  复制文件夹.olddir和newdir都只能是目录，且newdir必须不存在</span><br><span class="line"> </span><br><span class="line">os.<span class="built_in">rename</span>(&quot;oldname&quot;,&quot;newname&quot;)  重命名文件（目录）.文件或目录都是使用这条命令</span><br><span class="line"> </span><br><span class="line">shutil.<span class="built_in">move</span>(&quot;oldpos&quot;,&quot;newpos&quot;)  移动文件（目录）</span><br><span class="line"> </span><br><span class="line">os.<span class="built_in">rmdir</span>(&quot;<span class="built_in">dir</span>&quot;)  只能删除空目录</span><br><span class="line"> </span><br><span class="line">shutil.rmtree(&quot;<span class="built_in">dir</span>&quot;)  空目录、有内容的目录都可以删</span><br><span class="line"> </span><br><span class="line">os.<span class="built_in">chdir</span>(&quot;<span class="built_in">path</span>&quot;)  转换目录，换路径</span><br></pre></td></tr></table></figure>
<h2 id="nmap"><a class="markdownIt-Anchor" href="#nmap">#</a> <strong>nmap</strong></h2>
<p><strong>这里我们主要接受 python-nmap 模块的两个常用类，一个是 PortScanner () 类，实现一个 nmap 工具的端口扫描功能封装；另一个为 PortScannerHostDict () 类，实现存储与访问主机扫描结果</strong></p>
<p><strong>1、PortScanner () 类常用方法</strong><br>
<strong> 1-1、scan () 方法</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan(self, hosts=&#x27;127.0.0.1&#x27;, ports=None, arguments=&#x27;-sV&#x27;)</span><br></pre></td></tr></table></figure>
<p><strong>方法，实现指定主机、端口、namp 命令行参数的扫描。参数 hosts 为字符串类型，表示扫描的主机地址，格式可以用 &quot;<span class="exturl" data-url="aHR0cDovL3NjYW5tZS5ubWFwLm9yZw==">scanme.nmap.org</span>&quot;、“192.116.0-255.1-127”、“216.163.128.20/20&quot; 表示；参数 ports 为字符串类型，表示扫描的端口，可以用 &quot;22,53,110,143-4564&quot; 表示；参数 namp 命令行参数，格式为”-sU -sX -sC&quot;，例如：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nm = nmap.PortScanner()</span><br><span class="line">nm.scan(&#x27;192.168.209.121-122&#x27;, &#x27;22,80&#x27;)</span><br></pre></td></tr></table></figure>
<p><strong>1-2、command_line () 方法</strong><br>
<strong> command_line (self) 方法，返回的扫描方法映射到具体的 nmap 命令行，如：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nm.command_line()</span><br><span class="line">u&#x27;nmap -oX - -p 22,80 -sV 192.168.209.121-122&#x27;</span><br></pre></td></tr></table></figure>
<p><strong>1-3、scaninfo () 方法</strong><br>
<strong> scaninfo (self) 方法，返回 nmap 扫描信息，格式为字典类型，如：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;nm.scanninfo()</span><br><span class="line">&#123;&#x27;tcp&#x27;:&#123;&#x27;services&#x27;:&#x27;22,80&#x27;, &#x27;method&#x27;:&#x27;syn&#x27;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1-4、all_hosts () 方法</strong><br>
<strong> all_hosts (self) 方法，返回 nmap 扫描的主机清单，格式为列表类型，例如：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;192.168.209.121&#x27;, &#x27;192.168.209.122&#x27;]</span><br></pre></td></tr></table></figure>
<p><strong>2、PortScannerHostDict () 类常用方法</strong><br>
<strong> 2-1、hostname () 方法</strong><br>
<strong> hostname (self) 方法，返回扫描对象的主机名，如：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nm[&#x27;192.168.209.121&#x27;].hostname()</span><br></pre></td></tr></table></figure>
<p><strong>’liuyazhuang’</strong><br>
<strong>2-2、state () 方法</strong><br>
<strong> state (self) 方法，返回扫描对象的状态，包括 4 中状态 (up、down、unknown、skipped)，如：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nm[&#x27;192.168.209.121&#x27;].state()</span><br></pre></td></tr></table></figure>
<p><strong>’up’</strong><br>
<strong>2-3、all_protocols () 方法</strong><br>
<strong> all_protocols (self) 方法，返回扫描的协议，如:</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nm[&#x27;192.168.209.121&#x27;].all_protocols()</span><br></pre></td></tr></table></figure>
<p><strong>[‘tcp’]</strong><br>
<strong> 2-4、all_tcp () 方法</strong><br>
<strong> all_tcp (self) 方法，返回 TCP 协议扫描的端口，如：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nm[&#x27;192.168.209.121&#x27;].all_tcp()</span><br></pre></td></tr></table></figure>
<p><strong>[22,80]</strong><br>
<strong> 2-5、tcp () 方法</strong><br>
<strong> tcp (self, port) 方法，返回扫描 TCP 协议 port (端口) 的信息，如:</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nm[&#x27;192.168.209.121&#x27;].tcp(22)</span><br><span class="line">&#123;&#x27;state&#x27;:&#x27;open&#x27;, &#x27;reason&#x27;:&#x27;syn-ack&#x27;, &#x27;name&#x27;:&#x27;ssh&#x27;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sys模块-2"><a class="markdownIt-Anchor" href="#sys模块-2">#</a> <strong>sys 模块</strong></h2>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">sys.argv: 实现从程序外部向程序传递参数。</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="title">sys.exit</span>([<span class="title">arg</span>]): 程序中间的退出，<span class="title">arg</span>=0为正常退出。</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="title">sys.getdefaultencoding</span>(): 获取系统当前编码，一般默认为<span class="title">ascii</span>。</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="title">sys.setdefaultencoding</span>(): 设置系统默认编码，执行<span class="title">dir</span>（<span class="title">sys</span>）时不会看到这个方法，在解释器中执行不通过，可以先执行<span class="title">reload</span>(<span class="title">sys</span>)，在执行 <span class="title">setdefaultencoding</span>(&#x27;<span class="title">utf8</span>&#x27;)，此时将系统默认编码设置为<span class="title">utf8</span>。（见设置系统默认编码 ）</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="title">sys.getfilesystemencoding</span>(): 获取文件系统使用编码方式，<span class="title">Windows</span>下返回&#x27;<span class="title">mbcs</span>&#x27;，<span class="title">mac</span>下返回&#x27;<span class="title">utf</span>-8&#x27;.</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="title">sys.path</span>: 获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中<span class="title">import</span>时正确找到。</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="title">sys.platform</span>: 获取当前系统平台。</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="title">sys.stdin</span>,<span class="title">sys.stdout</span>,<span class="title">sys.stderr</span>: <span class="title">stdin</span> , <span class="title">stdout</span> , 以及<span class="title">stderr</span> 变量包含与标准<span class="title">I</span>/<span class="title">O</span> 流对应的流对象. 如果需要更好地控制输出,而<span class="title">print</span> 不能满足你的要求, 它们就是你所需要的. 你也可以替换它们, 这时候你就可以重定向输出和输入到其它设备( <span class="title">device</span> ), 或者以非标准的方式处理它们</span></span><br></pre></td></tr></table></figure>
<p><strong>sys.argv</strong></p>
<p><strong>功能：在外部向程序内部传递参数</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201115204741870.png" alt="image-20201115204741870"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201115204803153.png" alt="image-20201115204803153"></strong></p>
<p><strong>sys.exit(n)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">功能：执行到主程序末尾，解释器自动退出，但是如果需要中途退出程序，可以调用sys.exit函数，带有一个可选的整数参数返回给调用它的程序，表示你可以在主程序中捕获对sys.exit的调用。（0是正常退出，其他为异常）</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201115205105004.png" alt="image-20201115205105004"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201115205120882.png" alt="image-20201115205120882"></strong></p>
<p><strong>sys.modules</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">功能：sys.modules是一个全局字典，该字典是python启动后就加载在内存中。每当程序员导入新的模块，sys.modules将自动记录该模块。当第二次再导入该模块时，python会直接到字典中查找，从而加快了程序运行的速度。它拥有字典所拥有的一切方法。</span><br></pre></td></tr></table></figure>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201115205328555.png" alt="image-20201115205328555"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201115205344454.png" alt="image-20201115205344454"></strong></p>
<h2 id="scapy"><a class="markdownIt-Anchor" href="#scapy">#</a> <strong>scapy</strong></h2>
<p><strong>导入</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from scapy.all import *</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 使用Ether()方法生成一个以太网层数据包</span><br><span class="line">eth_packet = Ether()</span><br><span class="line"># 使用IP()方法生成一个网络层数据包</span><br><span class="line">ip_packet = IP()</span><br><span class="line"># 使用TCP()方法生成一个tcp数据包</span><br><span class="line">tcp_packet = TCP()</span><br><span class="line"># 使用UDP()方法生成一个udp数据包</span><br><span class="line">udp_packet = UDP()</span><br><span class="line"># 使用ICMP()方法生成一个udp数据包</span><br><span class="line">icmp_packet = ICMP()</span><br></pre></td></tr></table></figure>
<p><strong>上一小节中生成数据包，如果就长这样的话完全就是一个黑盒，我们需要一些方法来知道数据包（各字段）是什么内容。</strong></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 使用IP()方法生成一个tcp数据包</span><br><span class="line">ip_packet = IP()</span><br><span class="line"></span><br><span class="line"># 方法一、使用raw()方法查看</span><br><span class="line">raw(ip_packet)</span><br><span class="line"></span><br><span class="line"># 方法二、使用hexdump()查看。类似Wireshark</span><br><span class="line">hexdump(ip_packet)</span><br><span class="line"></span><br><span class="line"># 方法三、raw()配合协议类查看。最佳</span><br><span class="line"># 查看该数据包以太网层内容（下层内容不层示，上层内容不解析只以load形式展示）</span><br><span class="line">Ether(raw(ip_packet))</span><br><span class="line"># 查看该数据包网络层内容（下层内容不层示，上层内容不解析只以load形式展示）</span><br><span class="line">IP(raw(ip_packet))</span><br></pre></td></tr></table></figure>
<p><strong>上一小节中我们使用 raw 配合协议方法的方式清楚地看到了数据包中各字段的值，这些值是根据本机信息自动生成的，我们来看如何自定义各字段的值。</strong></p>
<p><strong>定义字段的值有两个种方法，一种是在构造时直接传递参数，另一种是在生成后重新赋值；至于参数名即是上一小节中打出的那些项。</strong></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ip_packet = IP(src=&quot;<span class="number">10</span>.<span class="number">10</span>.<span class="number">6</span>.<span class="number">92</span>&quot;,ttl=<span class="number">128</span>)</span><br><span class="line"># 查看数据包各项值，确认src项是否为<span class="number">10</span>.<span class="number">10</span>.<span class="number">6</span>.<span class="number">92</span>，ttl项是否为<span class="number">128</span></span><br><span class="line">IP(raw(ip_packet))</span><br><span class="line"></span><br><span class="line"># 方法二，在生成后重新赋值</span><br><span class="line"># 给src赋值<span class="number">10</span>.<span class="number">10</span>.<span class="number">6</span>.<span class="number">92</span>，ttl赋值<span class="number">128</span>；字段为字符的以字符串形式赋，字段为数值的以数值形式赋</span><br><span class="line">ip_packet.src = &quot;<span class="number">10</span>.<span class="number">10</span>.<span class="number">6</span>.<span class="number">93</span>&quot;</span><br><span class="line">ip_packet.ttl = <span class="number">200</span></span><br><span class="line"># 查看数据包各项值，确认src项是否为<span class="number">10</span>.<span class="number">10</span>.<span class="number">6</span>.<span class="number">93</span>，ttl项是否为<span class="number">200</span></span><br><span class="line">IP(raw(ip_packet))</span><br></pre></td></tr></table></figure>
<p><strong>构造多层协议，构造函数可使用 “/” 隔开，低层函数在前高层函数在后；最后使用构造函数中的最低层函数即可查看数据包内容。</strong></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 构造一个IP数据包，源mac设置为&quot;<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">11</span>&quot;，源ip设置为&quot;<span class="number">10</span>.<span class="number">10</span>.<span class="number">6</span>.<span class="number">92</span>&quot;</span><br><span class="line">ip_packet = Ether(src=&quot;<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">11</span>&quot;)/IP(src=&quot;<span class="number">10</span>.<span class="number">10</span>.<span class="number">6</span>.<span class="number">92</span>&quot;)</span><br><span class="line"># 当前构造函中最低层为Ether</span><br><span class="line">Ether(raw(ip_packet))</span><br><span class="line"></span><br><span class="line"># 定义一个TCP数据包，源mac设置为&quot;<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">11</span>&quot;，源ip设置为&quot;<span class="number">10</span>.<span class="number">10</span>.<span class="number">6</span>.<span class="number">92</span>&quot;，源端口设置为<span class="number">1234</span></span><br><span class="line">tcp_packet = Ether(src=&quot;<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">11</span>&quot;)/IP(src=&quot;<span class="number">10</span>.<span class="number">10</span>.<span class="number">6</span>.<span class="number">92</span>&quot;)/TCP(sport=<span class="number">1234</span>)</span><br><span class="line"># 当前构造函中最低层为Ether</span><br><span class="line">Ether(raw(tcp_packet))</span><br><span class="line"></span><br><span class="line"># 定义一个应用层数据包，应用层内容为&quot;GET / HTTP/<span class="number">1</span>.<span class="number">0</span>\r\n\r\n&quot;</span><br><span class="line">app_packet = IP()/TCP()/&quot;GET / HTTP/<span class="number">1</span>.<span class="number">0</span>\r\n\r\n&quot;</span><br><span class="line"># 当前构造函中最低层为IP</span><br><span class="line">IP(raw(app_packet))</span><br></pre></td></tr></table></figure>
<p><strong>send () 函数允许自定义网络层，sendp () 函数允许自定义以太网层。</strong></p>
<p><strong>不管 TCP 还是 UDP 都一样直接使用 send () 等函数即可，scapy 会自己选择 socket 类型</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">send(IP(dst&#x3D;&quot;10.10.6.92&quot;)&#x2F;ICMP())</span><br><span class="line"></span><br><span class="line">sendp(Ether()&#x2F;IP(dst&#x3D;&quot;10.10.6.92&quot;)&#x2F;ICMP())</span><br></pre></td></tr></table></figure>
<p><strong>sr1 () 函数参许自定义网络层，srp () 函数允许自定层数据链路层</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rec_packet &#x3D; sr1(IP(dst&#x3D;&quot;10.10.6.92&quot;)&#x2F;ICMP()&#x2F;&quot;abcdefg&quot;)</span><br><span class="line">rec_packet</span><br><span class="line"># 直接读取某项值</span><br><span class="line">rec_packet.src</span><br><span class="line"># 使用show()方法格式化输出</span><br><span class="line">rec_packet.show()</span><br></pre></td></tr></table></figure>
<p><strong>所谓 syn 扫描就是把 Flags 字段明确指定为 SYN</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rec_packet &#x3D; sr1(IP(dst&#x3D;&quot;10.10.6.92&quot;)&#x2F;TCP(dport&#x3D;80,flags&#x3D;&quot;S&quot;))</span><br><span class="line">rec_packet.show()</span><br></pre></td></tr></table></figure>
<h2 id="struct模块"><a class="markdownIt-Anchor" href="#struct模块">#</a> <strong>struct 模块</strong></h2>
<h2 id="struct模块中的函数"><a class="markdownIt-Anchor" href="#struct模块中的函数">#</a> <strong>struct 模块中的函数</strong></h2>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>函数</strong></th>
<th style="text-align:left"><strong>return</strong></th>
<th style="text-align:left"><strong>explain</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>pack(fmt,v1,v2…)</strong></td>
<td style="text-align:left"><strong>string</strong></td>
<td style="text-align:left"><strong>按照给定的格式 (fmt), 把数据转换成字符串 (字节流), 并将该字符串返回.</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>pack_into(fmt,buffer,offset,v1,v2…)</strong></td>
<td style="text-align:left"><strong>None</strong></td>
<td style="text-align:left"><strong>按照给定的格式 (fmt), 将数据转换成字符串 (字节流), 并将字节流写入以 offset 开始的 buffer 中.(buffer 为可写的缓冲区，可用 array 模块)</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>unpack(fmt,v1,v2……)</strong></td>
<td style="text-align:left"><strong>tuple</strong></td>
<td style="text-align:left"><strong>按照给定的格式 (fmt) 解析字节流，并返回解析结果</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>pack_from(fmt,buffer,offset)</strong></td>
<td style="text-align:left"><strong>tuple</strong></td>
<td style="text-align:left"><strong>按照给定的格式 (fmt) 解析以 offset 开始的缓冲区，并返回解析结果</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>calcsize(fmt)</strong></td>
<td style="text-align:left"><strong>size of fmt</strong></td>
<td style="text-align:left"><strong>计算给定的格式 (fmt) 占用多少字节的内存，注意对齐方式</strong></td>
</tr>
</tbody>
</table>
<p><strong>struct 提供用 format specifier 方式对数据进行打包和解包（Packing and Unpacking）。例如:</strong></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import struct</span><br><span class="line">import binascii</span><br><span class="line">values = (<span class="number">1</span>, &#x27;abc&#x27;, <span class="number">2</span>.<span class="number">7</span>)</span><br><span class="line">s = struct.Struct(&#x27;I3sf&#x27;)</span><br><span class="line">packed_data = s.pack(*values)</span><br><span class="line">unpacked_data = s.unpack(packed_data)</span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span> &#x27;Original values:&#x27;, values</span><br><span class="line"><span class="built_in">print</span> &#x27;<span class="built_in">Format</span> string :&#x27;, s.<span class="built_in">format</span></span><br><span class="line"><span class="built_in">print</span> &#x27;Uses :&#x27;, s.size, &#x27;bytes&#x27;</span><br><span class="line"><span class="built_in">print</span> &#x27;Packed Value :&#x27;, binascii.hexlify(packed_data)</span><br><span class="line"><span class="built_in">print</span> &#x27;Unpacked <span class="built_in">Type</span> :&#x27;, <span class="built_in">type</span>(unpacked_data), &#x27; Value:&#x27;, unpacked_data</span><br></pre></td></tr></table></figure>
<p><strong>Python 没有专门处理字节的数据类型。但由于 <code>b'str'</code>  可以表示字节，所以，字节数组＝二进制 str。而在 C 语言中，我们可以很方便地用 struct、union 来处理字节，以及字节和 int，float 的转换。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 获取用户输入十进制数</span><br><span class="line">dec &#x3D; int(input(&quot;输入数字：&quot;))</span><br><span class="line"></span><br><span class="line">print(&quot;十进制数为：&quot;, dec)</span><br><span class="line">print(&quot;转换为二进制为：&quot;, bin(dec))</span><br><span class="line">print(&quot;转换为八进制为：&quot;, oct(dec))</span><br><span class="line">print(&quot;转换为十六进制为：&quot;, hex(dec))</span><br></pre></td></tr></table></figure>
<p><strong>好在 Python 提供了一个 <code>struct</code>  模块来解决 <code>bytes</code>  和其他二进制数据类型的转换。</strong></p>
<p><strong> <code>struct</code>  的 <code>pack</code>  函数把任意数据类型变成 <code>bytes</code> ：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import struct</span><br><span class="line">&gt;&gt;&gt; struct.pack(&#39;&gt;I&#39;, 10240099)</span><br><span class="line">b&#39;\x00\x9c@c&#39;</span><br></pre></td></tr></table></figure>
<p><strong>后面的参数个数要和处理指令一致。</strong></p>
<p><strong> <code>pack</code>  的第一个参数是处理指令， <code>'&gt;I'</code>  的意思是：</strong></p>
<p><strong> <code>&gt;</code>  表示字节顺序是 big-endian，也就是网络序， <code>I</code>  表示 4 字节无符号整数。</strong></p>
<p><strong>后面的参数个数要和处理指令一致。</strong></p>
<p><strong><img data-src="https://img-blog.csdn.net/20180523160441215?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwNjM4ODMx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></strong></p>
<h2 id="ftplib模块"><a class="markdownIt-Anchor" href="#ftplib模块">#</a> <strong>ftplib 模块</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201121174909380.png" alt="image-20201121174909380"></strong></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">email</span><br><span class="line">电子邮件处理的包（也支持 MIME）</span><br><span class="line">rfc822</span><br><span class="line">RFC2822 邮件头解析器</span><br><span class="line">smtpd</span><br><span class="line">SMTP 服务器</span><br><span class="line">base64</span><br><span class="line">Base <span class="number">16</span>、<span class="number">32</span> 和 <span class="number">64</span> 数据编码（RFC <span class="number">3548</span>）</span><br><span class="line">mhlib</span><br><span class="line">处理 MH 文件夹和信息的类</span><br><span class="line">mailbox</span><br><span class="line">支持 mailbox 文件格式解析的类</span><br><span class="line">mailcap</span><br><span class="line">“mailcap”文件的处理模块</span><br><span class="line">mimetools</span><br><span class="line">（不建议使用）MIME 信息解析工具（使用上面的 email）</span><br><span class="line">mimetypes</span><br><span class="line">在文件名或 URL 到相关的 MIME 类型之间转换的模块</span><br><span class="line">MimeWriter</span><br><span class="line">（不建议使用）MIME 信息处理模块（使用上面的 email）</span><br><span class="line">mimify</span><br><span class="line">（不建议使用）信息的 MIME 处理工具（使用上面的 email）</span><br><span class="line">binascii</span><br><span class="line">二进制和 ASCII 转换</span><br><span class="line">binhex</span><br><span class="line">Binhex <span class="number">4</span> 编码和解码支持</span><br><span class="line"><span class="number">17</span>.<span class="number">5</span>.<span class="number">2</span> 其他网络协议</span><br><span class="line">表 <span class="number">17</span>.<span class="number">6</span></span><br><span class="line">模 块</span><br><span class="line">描 述</span><br><span class="line">ftplib</span><br><span class="line">FTP 协议客户端</span><br><span class="line">gopherlib</span><br><span class="line">Gopher 协议客户端</span><br><span class="line">httplib</span><br><span class="line">HTTP 和 HTTPS 协议客户端</span><br><span class="line">imaplib</span><br><span class="line">IMAP4 协议客户端</span><br><span class="line">nntplib</span><br><span class="line">NNTP 协议客户端</span><br><span class="line">poplib</span><br><span class="line">POP3 协议客户端</span><br><span class="line">smtplib</span><br><span class="line">SMTP 协议客户端</span><br><span class="line">telnetlib</span><br><span class="line">Telnet 协议客户端类</span><br></pre></td></tr></table></figure>
<p><strong>ftplib 模块中定义了基于 FTP 协议的 FTP 类，可以进行一些 FTP 工作。以下是一些 FTP 接口的说明。</strong></p>
<ul>
<li>
<p><em><em><em>class</em> ftplib.FTP(</em> <code>host='', user='', passwd='', acct='', timeout=None, source_address=None</code> </em>)***</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>方法</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>host</strong></td>
<td><strong>调用 connect (host) 方法</strong></td>
</tr>
<tr>
<td><strong>user</strong></td>
<td><strong>调用 login (user, passwd, acct) 方法</strong></td>
</tr>
<tr>
<td><strong>timeout</strong></td>
<td><strong>超时参数，若不指定则应用全局超时参数</strong></td>
</tr>
<tr>
<td><strong>source_address</strong></td>
<td><strong>二元组 (host, port)，连接前绑定的 socket 源地址</strong></td>
</tr>
</tbody>
</table>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以下是FTP类的方法说明</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>FTP.set_debuglevel(<em> <code>level</code> </em>)</strong></td>
<td><strong> <code>0</code> ：默认，无调试输出； <code>1</code> ：中等调试输出； <code>2</code> ：最大量 调试输出</strong></td>
<td><strong>该方法用来控制调试输出的量</strong></td>
</tr>
<tr>
<td><strong>FTP.connect(<em> <code>host='', port=0, timeout=None, source_address=None</code> </em>)</strong></td>
<td><strong> <code>host</code> ：主机地址； <code>port</code> : 根据 FTP 协议默认端口为 <code>21</code> ； <code>timeout</code> ：若不指定则使用 <code>全局超时参数</code> </strong></td>
<td><strong>用于链接 FTP 服务器，链接成功后无需再调用</strong></td>
</tr>
<tr>
<td><strong>FTP.login(<em> <code>user='anonymous', passwd='', acct=''</code> </em>)</strong></td>
<td><strong>参数指定用户名和密码，若未指定则匿名访问。 <code>user：'anonymous'，passwd：'anonymous@'</code> </strong></td>
<td><strong>只有在链接 FTP 服务器时用以验证使用</strong></td>
</tr>
<tr>
<td><strong>FTP.abort()</strong></td>
<td><strong>无参数</strong></td>
<td><strong>中断文件传输操作，不一定管用，尝试而已</strong></td>
</tr>
<tr>
<td><strong>FTP.getwelcome()</strong></td>
<td><strong>无参数</strong></td>
<td><strong>链接成功返回 “welcome” 信息</strong></td>
</tr>
<tr>
<td><strong>FTP.sendcmd(<em> <code>cmd</code> </em>)</strong></td>
<td></td>
<td><strong>发送简单命令给服务器，并返回相应字符串</strong></td>
</tr>
<tr>
<td><strong>FTP.voidcmd(<em> <code>cmd</code> </em>)</strong></td>
<td></td>
<td><strong>发送简单命令，并处理响应，若响应时成功码，啥也不返回，否则 raise  <code>error_replly</code> </strong></td>
</tr>
<tr>
<td><strong>FTP.retrbinary(<em> <code>cmd, callback, blocksize=8192, rest=None</code> </em>)</strong></td>
<td><strong> <code>cmd</code> ：RETR 命令， <code>callback</code> ：获取的数据块将要调用的函数， <code>blocksize</code> ：数据块的最大尺寸， <code>rest</code> ：</strong></td>
<td><strong>以 <code>BINARY模式</code> 获取文件，</strong></td>
</tr>
<tr>
<td><strong>FTP.retrlines(<em> <code>cmd, callback=None</code> </em>)</strong></td>
<td><strong> <code>cmd</code> ： <code>RETR</code>  命令</strong></td>
<td><strong>以 <code>ASCII</code>  模式获取文件或者文件夹列表</strong></td>
</tr>
<tr>
<td><strong>FTP.set_pasv(<em> <code>val</code> </em>)</strong></td>
<td><strong> <code>true</code> ：允许被动模式， <code>false</code> ：禁用被动模式。默认允许</strong></td>
<td><strong>允许或者禁用被动模式</strong></td>
</tr>
<tr>
<td><strong>FTP.storbinary(<em> <code>cmd, fp, blocksize=8192, callback=None, rest=None</code> </em>)</strong></td>
<td><strong> <code>cmd</code> ：合适的 <code>STOR</code>  命令。 <code>fp</code> ：文件对象，以 <code>read（）</code> 方法读取文件直到 EOF，以供存储。 <code>blocksize</code> ：数据块大小。 <code>callback</code> ：对数据块进行处理的方法。 <code>rest</code> ：</strong></td>
<td><strong>以 <code>BINARY</code>  模式存储文件</strong></td>
</tr>
<tr>
<td><strong>FTP.storlines(<em> <code>cmd, fp, callback=None</code> </em>)</strong></td>
<td><strong> <code>cmd</code> ：合适的 <code>STOR</code>  命令。 <code>fp</code> ：文件对象，以 <code>readline（）</code> 方法读取文件直到 EOF，以供存储。 <code>blocksize</code> ：数据块大小。 <code>callback</code> ：对数据块进行处理的方法。 <code>rest</code> ：</strong></td>
<td><strong>以 <code>ASCII</code>  模式存储文件</strong></td>
</tr>
<tr>
<td><strong>FTP.transfercmd(<em> <code>cmd, rest=None</code> </em>)</strong></td>
<td><strong>cmd：传输命令，rest：REST 命令</strong></td>
<td><strong>开启数据连接， <code>主动模式</code> 下发送 <code>EPRT</code>  或者 <code>PORT</code>  命令，并通过 cmd 发送传输命令，接受连接， <code>被动模式</code> 下发送 <code>EPSV</code>  或者 <code>PASV</code>  命令，连接服务器并通过 cmd 发送传输命令。两种模式下都要返回 <code>socket套接字</code> </strong></td>
</tr>
<tr>
<td><strong>FTP.ntransfercmd(<em> <code>cmd, rest=None</code> </em>)</strong></td>
<td></td>
<td><strong>返回一个包含数据连接和期望数据大小的元组</strong></td>
</tr>
<tr>
<td><strong>FTP.mlsd(<em> <code>path=&quot;&quot;, facts=[]</code> </em>)</strong></td>
<td><strong> <code>path</code> ：文件夹路径， <code>facts</code> ：期望信息字段列表</strong></td>
<td><strong>用 <code>MSLD</code>  命令获取文件下的文件信息列表，返回包含文件名称和对应信息的元组，其中部分期望信息可能未获得服务器允许</strong></td>
</tr>
<tr>
<td><strong>FTP.nlst(<em> <code>argument[, ...]</code> </em>)</strong></td>
<td><strong> <code>argument</code> ：文件夹路径</strong></td>
<td><strong>使用 <code>NLST</code>  命令获取文件夹下的文件名称列表</strong></td>
</tr>
<tr>
<td><strong>FTP.dir(<em> <code>argument[, ...]</code> </em>)</strong></td>
<td><strong> <code>argument</code> ：文件夹路径</strong></td>
<td><strong>使用 <code>LIST</code>  命令获取某路径下的文件夹列表，默认为当前目录</strong></td>
</tr>
<tr>
<td><strong>FTP.rename(<em> <code>fromname, toname</code> </em>)</strong></td>
<td><strong> <code>fromname</code> ：旧名称； <code>toname</code> ：新名称</strong></td>
<td><strong>修改文件名称</strong></td>
</tr>
<tr>
<td><strong>FTP.delete(<em> <code>filename)</code> </em></strong></td>
<td><strong> <code>filename</code> ：文件名</strong></td>
<td><strong>移除服务器中的某文件，若成功返回 <code>响应文本</code> ，否则返回 <code>error_perm</code> （许可错误） 或  <code>error_reply</code> （其他错误）</strong></td>
</tr>
<tr>
<td><strong>FTP.cwd(<em> <code>pathname</code> </em>)</strong></td>
<td><strong> <code>pathname</code> ：文件夹路径</strong></td>
<td><strong>设置当前文件夹</strong></td>
</tr>
<tr>
<td><strong>FTP.mkd(<em> <code>pathname</code> </em>)</strong></td>
<td><strong> <code>pathname</code> ：文件夹路径</strong></td>
<td><strong>服务器中新建文件夹</strong></td>
</tr>
<tr>
<td><strong>FTP.pwd()</strong></td>
<td></td>
<td><strong>返回当前文件夹的路径</strong></td>
</tr>
<tr>
<td><strong>FTP.rmd(<em> <code>dirname</code> </em>)</strong></td>
<td><strong> <code>dirname</code> ：文件夹名称</strong></td>
<td><strong>移除某个文件夹</strong></td>
</tr>
<tr>
<td><strong>FTP.size(<em> <code>filename</code> </em>)</strong></td>
<td><strong> <code>filename</code> ：文件名</strong></td>
<td><strong>请求文件大小，若请求成功则返回整数，否则返回 None；该命令非标准命令，但很多服务器支持</strong></td>
</tr>
<tr>
<td><strong>FTP.quit()</strong></td>
<td><strong>无参数</strong></td>
<td><strong>向服务器发送 <code>QUIT</code>  命令后，关闭连接，若服务器无法识别该命令，会响应错误</strong></td>
</tr>
<tr>
<td><strong>FTP.close()</strong></td>
<td><strong>无参数</strong></td>
<td><strong>单方面关闭连接，无法重复关闭连接</strong></td>
</tr>
</tbody>
</table>
<p><em><em><em>class</em> ftplib.FTP_TLS(</em> <code>host='', user='', passwd='', acct='', keyfile=None, certfile=None, context=None, timeout=None, source_address=None</code> </em>)**<br>
<strong> 该类是 FTP 类的子类，自 3.2 版本后增加了 tls 安全传输层协议，一下是该类的方法说明</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FTP_TLS.ssl_version()	使用的SSL的版本</span><br><span class="line">FTP_TLS.auth()	使用TLS或者SSL建立安全控制链接，取决于ssl_version()方法</span><br><span class="line">FTP_TLS.ccc()	</span><br><span class="line">FTP_TLS.prot_p()	建立安全的数据连接</span><br><span class="line">FTP_TLS.prot_c()	建立明文数据连接</span><br></pre></td></tr></table></figure>
<p><strong>FTP 有两种传输模式：ASCII 传输模式和 BINARY 传输模式。</strong></p>
<ul>
<li>
<pre><code>- ASCII传输模式：
  该方式可以根据服务器系统对文件进行自动调整，将原始文件的回车换行转换为系统对应的回车字符，比如Unix下是\n,Windows下是\r\n，Mac下是\r。`CGI脚本`和`普通HTML文件`（或其他文本文件）用ASCII模式上传，而其他的一些文件则使用二进制传输模式。
- BINARY传输模式：
  在二进制传输中，保存文件的位序，以便原始和拷贝的是逐位一一对应的。即使目的地机器上包含位序列的文件是没意义的。例如，macintosh以二进制方式传送可执行文件到Windows系统，在对方系统上，此文件不能执行。如果你在ASCII方式下传输二进制文件，即使不需要也仍会转译。这会使传输稍微变慢 ，也会损坏数据，使文件变得不能用。（在大多数计算机上，ASCII方式一般假设每一字符的第一有效位无意义，因为ASCII字符组合不使用它。如果你传输二进制文件，所有的位都是重要的。）如果你知道这两台机器具有相同的系统，则二进制方式对文本文件和数据文件都是有效的。
- 列举：
  - ASCII传输模式：用HTML和文本编写的文件必须用ASCII模式上传
  - 二进制传输模式：BINARY模式用来传送可执行文件，压缩文件，和图片文件
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;</span><br><span class="line">  FTP支持两种模式：一种方式叫做Standard (也就是 PORT方式，主动方式)， Standard模式下 FTP的客户端发送 PORT 命令到FTP服务器。另一种是 Passive (也就是PASV，被动方式) ，Passive模式下FTP的客户端发送 PASV命令到 FTP Server。</span><br><span class="line">  </span><br><span class="line">  Standard模式：</span><br><span class="line">  Port模式FTP 客户端首先和FTP服务器的TCP 21端口建立连接，通过这个通道发送命令，客户端需要接收数据的时候在这个通道上发送PORT命令。 PORT命令包含了客户端用什么端口接收数据。在传送数据的时候，服务器端通过自己的TCP 20端口连接至客户端的指定端口发送数据。 FTP server必须和客户端建立一个新的连接用来传送数据。（可以看到在这种方式下是客户端和服务器建立控制连接，服务器向客户端建立数据连接，其中，客户端的控制连接和数据连接的端口号是大于1024的两个端口号（临时端口），而FTP服务器的数据端口为20，控制端口为21）</span><br><span class="line">  Passive模式：</span><br><span class="line">  Passive模式在建立控制通道的时候和Standard模式类似，但建立连接后发送的不是Port命令，而是Pasv命令。FTP服务器收到Pasv命令后，随机打开一个临时端口（也叫自由端口，端口号大于1023小于65535）并且通知客户端在这个端口上传送数据的请求，客户端连接FTP服务器此端口，然后FTP服务器将通过这个端口进行数据的传送，这个时候FTP server不再需要建立一个新的和客户端之间的连接。（可以看到这种情况下的连接都是由客户端向服务器发起的，与下面所说的“为了解决服务器发起到客户的连接的问题，人们开发了一种不同的FTP连接方式。这就是所谓的被动方式”相对应，而服务器端的数据端口是临时端口，而不是常规的20）</span><br><span class="line">  注意：很多防火墙在设置的时候都是不允许接受外部发起的连接的，所以许多位于防火墙后或内网的FTP服务器不支持PASV模式，因为客户端无法穿过防火墙打开FTP服务器的高端端口；而许多内网的客户端不能用PORT模式登陆FTP服务器，因为从服务器的TCP 20无法和内部网络的客户端建立一个新的连接，造成无法工作。</span><br><span class="line">  &#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">## **request模块**</span><br><span class="line"></span><br><span class="line">**requests里提供了各种请求方式，比如：get，post，delete，put，具体如下所示：**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;cmd</span><br><span class="line">import requests </span><br><span class="line">requests.post(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;post&quot;) </span><br><span class="line">requests.put(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;put&quot;) </span><br><span class="line">requests.delete(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;delete&quot;) </span><br><span class="line">requests.get(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;get&quot;) </span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">**在使用requests时，无论你使用的请求方法是get也好，post也罢，他们都会给你返回一个响应的对象，而针对这个对象有一些特定的方法，能够让你进一步解析响应从而得到你想要的数据，如下：**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;&#96;cmd</span><br><span class="line">response.json() 　　　　　　　　　　# 以json的形式返回响应内容，对象格式为dict response.content 　　　　　　　　　 # 以二进制的形式返回响应内容，对象格式为bytes response.text 　　　　　　　　　　　# 以字符串的形式返回响应内容，对象格式为str response.url 　　　　　　　　　　　　# 返回请求的url response.status_code 　　　　　　　# 返回本次请求的状态码 response.reason 　　　　　　　　　　# 返回状态码对应的原因 response.headers 　　　　　　　　　# 返回响应头 response.cookies 　　　　　　　　　# 返回cookice信息 response.raw 　　　　　　　　　　　# 返回原始响应体 response.encoding 　　　　　　　　# 返回编码格式</span><br></pre></td></tr></table></figure>





</code></pre>
</li>
</ul>
<h2 id="正则表达式"><a class="markdownIt-Anchor" href="#正则表达式">#</a> <strong>正则表达式</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201121170358585.png" alt="image-20201121170358585"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201121170409573.png" alt="image-20201121170409573"></strong></p>
<h2 id="特殊字符表示字符集"><a class="markdownIt-Anchor" href="#特殊字符表示字符集">#</a> <strong>特殊字符表示 (字符集)</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201121170600029.png" alt="image-20201121170600029"></strong></p>
<p><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201122142617744.png" alt="image-20201122142617744"></p>
<p><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201122142847883.png" alt="image-20201122142847883"></p>
<h2 id="常用函数和方法"><a class="markdownIt-Anchor" href="#常用函数和方法">#</a> <strong>常用函数和方法</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201121170714542.png" alt="image-20201121170714542"></strong></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; m = re.match(&#x27;foo&#x27;, &#x27;foo&#x27;)</span><br><span class="line">#模式匹配字符串</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">if</span> m is <span class="keyword">not</span> None:</span><br><span class="line">#如果成功，显示匹配</span><br><span class="line">... m.group()</span><br><span class="line">...</span><br><span class="line">&#x27;foo&#x27;</span><br></pre></td></tr></table></figure>
<p><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201122145049966.png" alt="image-20201122145049966"></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这是当匹配失败时的例子，它返回 None：</span><br><span class="line">&gt;&gt;&gt; m = re.match(&#x27;foo&#x27;, &#x27;bar&#x27;)</span><br><span class="line">#模式不匹配字符串</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">if</span> m is <span class="keyword">not</span> None: m.group()</span><br><span class="line">#<span class="number">1</span> 行的 <span class="keyword">if</span> 子句  不显示</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; m = re.search(&#x27;foo&#x27;, &#x27;seafood&#x27;)</span><br><span class="line">#改用 search()</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">if</span> m is <span class="keyword">not</span> None: m.group()</span><br><span class="line">...</span><br><span class="line">&#x27;foo&#x27;</span><br><span class="line">#用 search 成功匹配，用 match 匹配失败</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p><strong>创建字符集合（[ ]）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#39;&gt;&gt;&gt; m &#x3D; re.match(&#39;[cr][23][dp][o2]&#39;, &#39;c3po&#39;)</span><br><span class="line">#匹配&#39;c3po&#39;</span><br><span class="line">&gt;&gt;&gt; if m is not None: m.group()</span><br><span class="line">...</span><br><span class="line">&#39;c3po&#39;</span><br><span class="line">&gt;&gt;&gt; m &#x3D; re.match(&#39;[cr][23][dp][o2]&#39;, &#39;c2do&#39;)</span><br><span class="line">#匹配&#39;c2do&#39;</span><br><span class="line">&gt;&gt;&gt; if m is not None: m.group()</span><br><span class="line">...</span><br><span class="line">&#39;c2do&#39;</span><br><span class="line">&gt;&gt;&gt; m &#x3D; re.match(&#39;r2d2|c3po&#39;, &#39;c2do&#39;)</span><br><span class="line">#不匹配&#39;c2do&#39;</span><br><span class="line">&gt;&gt;&gt; if m is not None: m.group()</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; m &#x3D; re.match(&#39;r2d2|c3po&#39;, &#39;r2d2&#39;)</span><br><span class="line">#匹配&#39;r2d2&#39;</span><br><span class="line">&gt;&gt;&gt; if m is not None: m.group()</span><br><span class="line">...</span><br><span class="line">&#39;r2d2&#39;&#39;</span><br></pre></td></tr></table></figure>
<p><strong>findall</strong></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; m = re.match(&#x27;[cr][<span class="number">23</span>][dp][o2]&#x27;, &#x27;c3po&#x27;)</span><br><span class="line">#匹配&#x27;c3po&#x27;</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">if</span> m is <span class="keyword">not</span> None: m.group()</span><br><span class="line">...</span><br><span class="line">&#x27;c3po&#x27;</span><br><span class="line">&gt;&gt;&gt; m = re.match(&#x27;[cr][<span class="number">23</span>][dp][o2]&#x27;, &#x27;c2do&#x27;)</span><br><span class="line">#匹配&#x27;c2do&#x27;</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">if</span> m is <span class="keyword">not</span> None: m.group()</span><br><span class="line">...</span><br><span class="line">&#x27;c2do&#x27;</span><br><span class="line">&gt;&gt;&gt; m = re.match(&#x27;r2d2|c3po&#x27;, &#x27;c2do&#x27;)</span><br><span class="line">#不匹配&#x27;c2do&#x27;</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">if</span> m is <span class="keyword">not</span> None: m.group()</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; m = re.match(&#x27;r2d2|c3po&#x27;, &#x27;r2d2&#x27;)</span><br><span class="line">#匹配&#x27;r2d2&#x27;</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">if</span> m is <span class="keyword">not</span> None: m.group()</span><br><span class="line">...</span><br><span class="line">&#x27;r2d2&#x27;</span><br></pre></td></tr></table></figure>
<p><strong>sub ()（和 subn ()）进行搜索和替换</strong></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re.sub(&#x27;X&#x27;, &#x27;Mr. Smith&#x27;, &#x27;attn: X\n\nDear X,\n&#x27;)</span><br><span class="line">&#x27;attn: Mr. Smith\<span class="number">012</span>\<span class="number">012</span>Dear Mr. Smith,\<span class="number">012</span>&#x27;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; re.subn(&#x27;X&#x27;, &#x27;Mr. Smith&#x27;, &#x27;attn: X\n\nDear X,\n&#x27;)</span><br><span class="line">(&#x27;attn: Mr. Smith\<span class="number">012</span>\<span class="number">012</span>Dear Mr. Smith,\<span class="number">012</span>&#x27;, <span class="number">2</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span> re.sub(&#x27;X&#x27;, &#x27;Mr. Smith&#x27;, &#x27;attn: X\n\nDear X,\n&#x27;)</span><br><span class="line"><span class="function">attn: <span class="title">Mr</span>. <span class="title">Smith</span></span></span><br><span class="line"><span class="function"><span class="title">Dear</span> <span class="title">Mr</span>. <span class="title">Smith</span>,</span></span><br><span class="line"><span class="function">&gt;&gt;&gt; <span class="title">re.sub</span>(&#x27;[<span class="title">ae</span>]&#x27;, &#x27;<span class="title">X</span>&#x27;, &#x27;<span class="title">abcdef</span>&#x27;)</span></span><br><span class="line"><span class="function">&#x27;<span class="title">XbcdXf</span>&#x27;</span></span><br><span class="line"><span class="function">&gt;&gt;&gt; <span class="title">re.subn</span>(&#x27;[<span class="title">ae</span>]&#x27;, &#x27;<span class="title">X</span>&#x27;, &#x27;<span class="title">abcdef</span>&#x27;)</span></span><br><span class="line"><span class="function">(&#x27;<span class="title">XbcdXf</span>&#x27;, 2)</span></span><br></pre></td></tr></table></figure>
<p><strong>用 split () 分割</strong></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re.split(&#x27;:&#x27;, &#x27;str1:str2:str3&#x27;)</span><br><span class="line">[&#x27;str1&#x27;, &#x27;str2&#x27;, &#x27;str3&#x27;]</span><br></pre></td></tr></table></figure>
<h2 id="python-网络编程"><a class="markdownIt-Anchor" href="#python-网络编程">#</a> <strong>python 网络编程</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201121171535369.png" alt="image-20201121171535369"></strong></p>
<p><strong>创建 tcp 服务器</strong></p>
<h2 id="tcp时间戳服务器tstservpy"><a class="markdownIt-Anchor" href="#tcp时间戳服务器tstservpy">#</a> <strong>TCP 时间戳服务器（<span class="exturl" data-url="aHR0cDovL3RzVHNlcnYucHk=">tsTserv.py</span>）</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201121171731015.png" alt="image-20201121171731015"></strong></p>
<p><strong>TCP 客户端</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201121171852321.png" alt="image-20201121171852321"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201121171924713.png" alt="image-20201121171924713"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201121171931438.png" alt="image-20201121171931438"></strong></p>
<h2 id="udp时间戳服务器tsuservpy"><a class="markdownIt-Anchor" href="#udp时间戳服务器tsuservpy">#</a> <strong>UDP 时间戳服务器（<span class="exturl" data-url="aHR0cDovL3RzVXNlcnYucHk=">tsUserv.py</span>）</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201121172044894.png" alt="image-20201121172044894"></strong></p>
<p><strong>UDP 客户端（<span class="exturl" data-url="aHR0cDovL3RzVWNsbnQucHk=">tsUclnt.py</span>）</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201121172216173.png" alt="image-20201121172216173"></strong></p>
<h2 id="socket模块属性"><a class="markdownIt-Anchor" href="#socket模块属性">#</a> <strong>socket 模块属性</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201121172346313.png" alt="image-20201121172346313"></strong></p>
<h2 id="socketserver-模块"><a class="markdownIt-Anchor" href="#socketserver-模块">#</a> <strong>SocketServer 模块</strong></h2>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">aseServer</span><br><span class="line">包含服务器的核心功能与混合（mix-<span class="keyword">in</span>）类挂钩；这个类只用于派生，所以不</span><br><span class="line">会生成这个类的实例；可以考虑使用 TCPServer 和 UDPServer</span><br><span class="line">TCPServer/UDPServer</span><br><span class="line">基本的网络同步 TCP/UDP 服务器</span><br><span class="line">UnixStreamServer/ UnixDatagramServer</span><br><span class="line">基本的基于文件同步 TCP/UDP 服务器</span><br><span class="line">ForkingMixIn/ ThreadingMixIn</span><br><span class="line">实现了核心的进程化或线程化的功能；作为混合类，与服务器类一并使用以</span><br><span class="line">提供一些异步特性；这个类不会直接实例化</span><br><span class="line">ForkingTCPServer/ ForkingUDPServer</span><br><span class="line">ForkingMixIn 和 TCPServer/UDPServer 的组合</span><br><span class="line">ThreadingTCPServer/ ThreadingUDPServer</span><br><span class="line">ThreadingMixIn 和 TCPServer/UDPServer 的组合</span><br><span class="line">BaseRequestHandler</span><br><span class="line">包含处理服务请求的核心功能。这个类只用于派生，所以不会生成这个类的</span><br><span class="line">实例可以考虑使用 StreamRequestHandler 或 DatagramRequestHandler</span><br><span class="line">StreamRequestHandler/ DatagramRequestHandler</span><br><span class="line">用于 TCP/UDP 服务器的服务处理工具</span><br></pre></td></tr></table></figure>
<h2 id="socketserver-时间戳-tcp-服务器tstservsspy"><a class="markdownIt-Anchor" href="#socketserver-时间戳-tcp-服务器tstservsspy">#</a> <strong>SocketServer 时间戳 TCP 服务器（<span class="exturl" data-url="aHR0cDovL1RzVHNlcnZzcy5weQ==">TsTservss.py</span>）</strong></h2>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201121174422386.png" alt="image-20201121174422386"></strong></p>
<p><strong>SocketServer 时间戳 TCP 客户端（<span class="exturl" data-url="aHR0cDovL3RzVGNsbnRTUy5weQ==">tsTclntSS.py</span>)</strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201121174605619.png" alt="image-20201121174605619"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201121174702083.png" alt="image-20201121174702083"></strong></p>
<p><strong><img data-src="E:%5Ctypora%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201121174709293.png" alt="image-20201121174709293"></strong></p>

  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2021-05-04 17:13:58" itemprop="dateModified" datetime="2021-05-04T17:13:58+08:00">2021-05-04</time>
  </span>
  <span id="2021/05/04/python学习笔记/" class="item leancloud_visitors" data-flag-title="" title="阅读次数">
      <span class="icon">
        <i class="ic i-eye"></i>
      </span>
      <span class="text">阅读次数</span>
      <span class="leancloud-visitors-count"></span>
      <span class="text">次</span>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> 赞赏</button>
  <p>请我喝[茶]~(￣▽￣)~*</p>
  <div id="qr">
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>chun <i class="ic i-at"><em>@</em></i>go-forward
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="http://chungod.github.io/2021/05/04/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="">http://chungod.github.io/2021/05/04/python学习笔记/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2021/05/04/php%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclil3m4ej20zk0m8tn8.jpg" title="php危险函数">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>php危险函数</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2021/05/04/paramiko%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giciukx8a7j20zk0m8aio.jpg" title="Paramiko模块利用">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>Paramiko模块利用</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#python-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text"> python 核心编程总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">1.1.</span> <span class="toc-text"> 第二章快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.2.</span> <span class="toc-text"> 运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.</span> <span class="toc-text"> 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%E5%92%8C"><span class="toc-number">2.1.</span> <span class="toc-text"> 切片和’’&#39;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%BB%84"><span class="toc-number">2.2.</span> <span class="toc-text"> 元组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E5%85%B8"><span class="toc-number">2.3.</span> <span class="toc-text"> 字典</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.</span> <span class="toc-text"> 条件语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text"> 列表解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#open%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text"> open 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#readreadlinereadlines"><span class="toc-number">5.1.</span> <span class="toc-text"> read.readline.readlines</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#with-open-%E5%92%8C-open"><span class="toc-number">6.</span> <span class="toc-text"> with open 和 open</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#file-%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text"> file 对象方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text"> 定义函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sys%E6%A8%A1%E5%9D%97"><span class="toc-number">7.1.</span> <span class="toc-text"> sys 模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="toc-number">7.2.</span> <span class="toc-text"> 实用函数（内建函数）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5%E5%92%8C%E8%AF%AD%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text"> 语句和语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#python-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">9.</span> <span class="toc-text"> python 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E7%89%87"><span class="toc-number">10.</span> <span class="toc-text"> 切片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.</span> <span class="toc-text"> 布尔类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C"><span class="toc-number">12.</span> <span class="toc-text"> &#x2F; 和 &#x2F;&#x2F;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0"><span class="toc-number">13.</span> <span class="toc-text"> 数值工厂函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E5%87%BD%E6%95%B0"><span class="toc-number">14.</span> <span class="toc-text"> 功能函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">15.</span> <span class="toc-text"> 进制转换函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ascii%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">16.</span> <span class="toc-text"> ASCII 转换函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A8%A1%E5%9D%97"><span class="toc-number">17.</span> <span class="toc-text"> 相关模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">18.</span> <span class="toc-text"> 类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AC%A6%E5%8F%B7"><span class="toc-number">19.</span> <span class="toc-text"> 字符串符号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BE%85%E5%8A%A9%E6%8C%87%E4%BB%A4"><span class="toc-number">20.</span> <span class="toc-text"> 格式化操作符辅助指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#enumerate"><span class="toc-number">21.</span> <span class="toc-text"> enumerate()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zip"><span class="toc-number">22.</span> <span class="toc-text"> zip()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reversed"><span class="toc-number">23.</span> <span class="toc-text"> reversed</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%BB%84-2"><span class="toc-number">24.</span> <span class="toc-text"> 元组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="toc-number">25.</span> <span class="toc-text"> 列表类型内建函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="toc-number">26.</span> <span class="toc-text"> 字符串内建函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A8%A1%E5%9D%97-2"><span class="toc-number">27.</span> <span class="toc-text"> 相关模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">28.</span> <span class="toc-text"> 浅拷贝和深拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B%E5%AD%97%E5%85%B8"><span class="toc-number">29.</span> <span class="toc-text"> 映射类型：字典</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">30.</span> <span class="toc-text"> 映射类型相关的函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dict"><span class="toc-number">31.</span> <span class="toc-text"> dict.*()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set%E5%92%8Cfrozenset"><span class="toc-number">32.</span> <span class="toc-text"> set 和 frozenset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5-2"><span class="toc-number">33.</span> <span class="toc-text"> 条件语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E5%BA%8F%E5%88%97%E7%9B%B8%E5%85%B3%E7%9A%84%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="toc-number">34.</span> <span class="toc-text"> 与序列相关的内建函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E6%A0%B7%E4%BE%8B"><span class="toc-number">35.</span> <span class="toc-text"> 矩阵样例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#os-%E6%A8%A1%E5%9D%97%E7%9A%84%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E8%AE%BF%E9%97%AE%E5%87%BD%E6%95%B0"><span class="toc-number">36.</span> <span class="toc-text"> os 模块的文件 &#x2F; 目录访问函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ospath%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E5%90%8D%E8%AE%BF%E9%97%AE%E5%87%BD%E6%95%B0"><span class="toc-number">37.</span> <span class="toc-text"> os.path 模块中的路径名访问函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A8%A1%E5%9D%97-3"><span class="toc-number">38.</span> <span class="toc-text"> 相关模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#python-%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E9%94%99%E8%AF%AF"><span class="toc-number">39.</span> <span class="toc-text"> python 中的异常错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try-except%E8%AF%AD%E5%8F%A5"><span class="toc-number">40.</span> <span class="toc-text"> try-except 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#raise%E8%AF%AD%E5%8F%A5"><span class="toc-number">41.</span> <span class="toc-text"> raise 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#python-%E5%86%85%E5%BB%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">42.</span> <span class="toc-text"> python 内建异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#operator%E6%A8%A1%E5%9D%97"><span class="toc-number">43.</span> <span class="toc-text"> operator 模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84funcargskwargs"><span class="toc-number">44.</span> <span class="toc-text"> python 代码中的 func (args,kwargs)*</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda"><span class="toc-number">45.</span> <span class="toc-text"> lambda</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#global%E7%94%A8%E6%B3%95"><span class="toc-number">46.</span> <span class="toc-text"> global 用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#python-%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">47.</span> <span class="toc-text"> python 名称空间与作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#from-import-%E8%AF%AD%E5%8F%A5"><span class="toc-number">48.</span> <span class="toc-text"> from-import 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#format%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%87%BD%E6%95%B0"><span class="toc-number">49.</span> <span class="toc-text"> format 格式化函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#join"><span class="toc-number">50.</span> <span class="toc-text"> join()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#threading"><span class="toc-number">51.</span> <span class="toc-text"> threading</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#queue%E6%A8%A1%E5%9D%97%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">52.</span> <span class="toc-text"> queue 模块 (线程间通信)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#optparse%E6%A8%A1%E5%9D%97"><span class="toc-number">53.</span> <span class="toc-text"> optparse 模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sysargv%E7%94%A8%E6%B3%95%E7%AE%80%E6%98%8E"><span class="toc-number">54.</span> <span class="toc-text"> sys.argv [] 用法简明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#socket-%E6%A8%A1%E5%9D%97"><span class="toc-number">55.</span> <span class="toc-text"> socket 模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#time-%E6%A8%A1%E5%9D%97"><span class="toc-number">56.</span> <span class="toc-text"> time 模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#subprocess-%E6%A8%A1%E5%9D%97"><span class="toc-number">57.</span> <span class="toc-text"> subprocess 模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#os%E6%A8%A1%E5%9D%97"><span class="toc-number">58.</span> <span class="toc-text"> os 模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nmap"><span class="toc-number">59.</span> <span class="toc-text"> nmap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sys%E6%A8%A1%E5%9D%97-2"><span class="toc-number">60.</span> <span class="toc-text"> sys 模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scapy"><span class="toc-number">61.</span> <span class="toc-text"> scapy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct%E6%A8%A1%E5%9D%97"><span class="toc-number">62.</span> <span class="toc-text"> struct 模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">63.</span> <span class="toc-text"> struct 模块中的函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ftplib%E6%A8%A1%E5%9D%97"><span class="toc-number">64.</span> <span class="toc-text"> ftplib 模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">65.</span> <span class="toc-text"> 正则表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E8%A1%A8%E7%A4%BA%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">66.</span> <span class="toc-text"> 特殊字符表示 (字符集)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">67.</span> <span class="toc-text"> 常用函数和方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#python-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">68.</span> <span class="toc-text"> python 网络编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp%E6%97%B6%E9%97%B4%E6%88%B3%E6%9C%8D%E5%8A%A1%E5%99%A8tstservpy"><span class="toc-number">69.</span> <span class="toc-text"> TCP 时间戳服务器（tsTserv.py）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#udp%E6%97%B6%E9%97%B4%E6%88%B3%E6%9C%8D%E5%8A%A1%E5%99%A8tsuservpy"><span class="toc-number">70.</span> <span class="toc-text"> UDP 时间戳服务器（tsUserv.py）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#socket%E6%A8%A1%E5%9D%97%E5%B1%9E%E6%80%A7"><span class="toc-number">71.</span> <span class="toc-text"> socket 模块属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#socketserver-%E6%A8%A1%E5%9D%97"><span class="toc-number">72.</span> <span class="toc-text"> SocketServer 模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#socketserver-%E6%97%B6%E9%97%B4%E6%88%B3-tcp-%E6%9C%8D%E5%8A%A1%E5%99%A8tstservsspy"><span class="toc-number">73.</span> <span class="toc-text"> SocketServer 时间戳 TCP 服务器（TsTservss.py）</span></a></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="chun"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">chun</p>
  <div class="description" itemprop="description">欢迎来到我的博客(*^﹏^*),本人为新人,你可以阅读我的学习笔记并提出独到的见解~我们将互相学习,共同进步,望大佬们勿喷</div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">8</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">7</span>
        <span class="name">标签</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lvdXJuYW1l" title="https:&#x2F;&#x2F;github.com&#x2F;yourname"><i class="ic i-github"></i></span>
      <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span>
      <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span>
      <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPXlvdXJpZA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;yourid"><i class="ic i-cloud-music"></i></span>
      <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span>
      <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

    
  <li class="item">
    <a href="/link/" rel="section"><i class="ic i-link"></i>links</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2021/05/04/php%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2021/05/04/paramiko%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2021/04/10/linux%E6%8F%90%E6%9D%83%E7%AC%94%E8%AE%B0/" title="Linux提权">Linux提权</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2021/04/21/meterpreter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/" title="meterpreter学习笔记">meterpreter学习笔记</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2021/05/04/php%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0/" title="php危险函数">php危险函数</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2021/04/16/Windows%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83/" title="Windows内核提权">Windows内核提权</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2021/05/04/paramiko%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/" title="Paramiko模块利用">Paramiko模块利用</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2021/05/04/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="未命名">未命名</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2021/05/01/upload-labs%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="upload-labs通关记录">upload-labs通关记录</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2021/04/09/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/" title="内存取证">内存取证</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最新评论</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2021</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">chun @ go-forward</span>
  </div>
  <div class="count">
    <span class="post-meta-item-icon">
      <i class="ic i-chart-area"></i>
    </span>
    <span title="站点总字数">89k 字</span>

    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="ic i-coffee"></i>
    </span>
    <span title="站点阅读时长">1:21</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2021/05/04/python学习笔记/',
    favicon: {
      show: "（●´3｀●）やれやれだぜ",
      hide: "(´Д｀)大変だ！"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
